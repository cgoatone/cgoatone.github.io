<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bitset</title>
    <url>/2020/07/27/bitset/</url>
    <content><![CDATA[<p>bitset是c++中的一个stl</p>
<a id="more"></a>
<p>如果需要使用bitset，则需要在头文件中定义#include<bitset></p>
<p>它是一种存储二进制字符串的结构，每一位只能为0或1，每一位只占用1bit</p>
<p>我们通常可以这样构造</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;长度&gt; 名称;</span><br><span class="line"><span class="built_in">bitset</span>&lt;12&gt; a;</span><br></pre></td></tr></table></figure>
<p>我们可以像操纵数组一样操纵bitset</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;12&gt; a;</span><br><span class="line"></span><br><span class="line">a[i]=<span class="number">1</span> <span class="comment">//给bitset的第i为赋值为1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i]; <span class="comment">//输入一个01字符串到bitset里</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出bitset的第i位</span></span><br></pre></td></tr></table></figure>
<p>bitset自带有一些常用的二进制操纵符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;12&gt; a,b;</span><br><span class="line"></span><br><span class="line">a^b <span class="comment">//异或 相同为0不同为1</span></span><br><span class="line">a&amp;b <span class="comment">//按位与 同1为1其余为0</span></span><br><span class="line">a|b <span class="comment">//按位或 有1为1其余为0</span></span><br><span class="line">a&lt;&lt;=<span class="number">2</span> <span class="comment">//左移2位并赋值</span></span><br><span class="line">a&gt;&gt;=<span class="number">2</span> <span class="comment">//右移2位并赋值</span></span><br><span class="line">a&lt;&lt;<span class="number">2</span> <span class="comment">//左移2位</span></span><br><span class="line">a&gt;&gt;<span class="number">2</span> <span class="comment">//右移2位</span></span><br><span class="line">~a <span class="comment">//按位取反</span></span><br><span class="line">a==b <span class="comment">//判断是否相等</span></span><br><span class="line">a!=b <span class="comment">//判断是否不相等</span></span><br></pre></td></tr></table></figure>
<p>二进制还有一些经典的操作</p>
<p>a为一个二进制字符串</p>
<p>1.lowbit操作(找到最后一个1所在的位置)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=a&amp;(-a) <span class="comment">//a就为最后一个1所在的位置</span></span><br></pre></td></tr></table></figure>
<p>2.清零最低位的1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=a&amp;(a<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<p>3.一个数异或偶数次还是原来的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=^(^a)</span><br></pre></td></tr></table></figure>
<p>4.判断奇偶</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x&amp;<span class="number">1</span>==<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>5.判断第i位是否为1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(a&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>[转载]化学方程式配平的几个方法</title>
    <url>/2020/08/08/%5B%E8%BD%AC%E8%BD%BD%5D%E5%8C%96%E5%AD%A6%E6%96%B9%E7%A8%8B%E5%BC%8F%E9%85%8D%E5%B9%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>我最近学了化学，有一点头疼的就是化学方程式的配平。于是我在百度知道上查到了化学方程式配平的几种方法</p>
<a id="more"></a>
<h2 id="（一）最小公倍数法"><a href="#（一）最小公倍数法" class="headerlink" title="（一）最小公倍数法"></a>（一）最小公倍数法</h2><p>这种方法适合常见的难度不大的化学方程式。例如，KClO₃→KCl+O₂↑在这个反应式中右边氧原子个数为2，左边是3，则最小公倍数为6，因此KClO₃前系数应配2，O2前配3，式子变为：2KClO₃→2KCl+3O₂↑，由于左边钾原子和氯原子数变为2个，则KCl前应配系数2，短线改为等号，标明条件即可： 2KClO₃=2KCl+3O₂↑</p>
<h2 id="（二）奇偶配平法"><a href="#（二）奇偶配平法" class="headerlink" title="（二）奇偶配平法"></a>（二）奇偶配平法</h2><p>这种方法适用于化学方程式两边某一元素多次出现，并且两边的该元素原子总数有一奇一偶，</p>
<p>例如：C2H2+O2→CO2+H2O，此方程式配平从先出现次数最多的氧原子配起。</p>
<p>O2内有2个氧原子，无论化学式前系数为几，氧原子总数应为偶数。故右边H2O的系数应配2（若推出其它的分子系数出现分数则可配4），</p>
<p>由此推知C2H2前2，式子变为：2C2H2+O2→CO2+2H2O，由此可知CO2前系数应为4，最后配单质O2为5，把短线改为等号，写明条件即可：2C2H2+5O2==4CO2+2H2O 　</p>
<p>e.g.</p>
<p>（1）从化学式较复杂的一种生成物推求有关反应物化学式的化学计量数和这一生成物的化学计量数；</p>
<p>（2）根据求得的化学式的化学计量数，再找出其它化学式的倾泄计量数，这样即可配平。 　例如：Fe2O3 + CO——Fe + CO2 　　</p>
<p>观察： 　　</p>
<p>所以，1个Fe2O3应将3个“O”分别给3个CO，使其转变为3个CO2。即 Fe2O3 + 3CO——Fe + 3CO2 </p>
<p>再观察上式：左边有2个Fe（Fe2O3），所以右边Fe的系数应为2。</p>
<p>即 Fe2O3 + 3CO——2Fe + 3CO2 </p>
<p>这样就得到配平的化学方程式了 　　</p>
<p>Fe2O3 + 3CO == 2Fe + 3CO2（反应条件高温) 　　</p>
<p>例：配平H2O + Fe →Fe2O3 + H2 　　</p>
<p>第一步：配平氧原子3H2O + Fe →Fe2O3+ H2 　　</p>
<p>第二步：配平氢原子、铁原子3H2O + 2Fe →Fe2O3+ 3H2 　　</p>
<p>第三步：配平后的化学方程式：3H2O +2Fe==Fe2O3+ 3H2 编辑本段</p>
<h2 id="（三）观察法配平"><a href="#（三）观察法配平" class="headerlink" title="（三）观察法配平"></a>（三）观察法配平</h2><p>有时方程式中会出现一种化学式比较复杂的物质，我们可通过这个复杂的分子去推其他化学式的系数，例如：Fe+H2O──Fe3O4+H2，Fe3O4化学式较复杂，显然，Fe3O4中Fe来源于单质Fe，O来自于H2O，则Fe前配3，H2O前配4，则式子为：3Fe+4H2O=Fe3O4+H2由此推出H2系数为4，写明条件，短线改为等号即可：3Fe+4H2O(g)==Fe3O4+4H2↑</p>
]]></content>
      <categories>
        <category>化学</category>
      </categories>
      <tags>
        <tag>化学</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/2020/07/25/hello-world/</url>
    <content><![CDATA[<p>这是我的第一篇blog</p>
<a id="more"></a>
<p>我的微信公众号是超级初中生，欢迎大家扫码关注</p>
<p><img src="https://i.loli.net/2020/07/26/oFH45KU1E3L2Qfd.jpg" alt="微信公众号"></p>
<p>我的头条号的名字也是超级初中生，欢迎大家关注</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>csp-j2019解题报告</title>
    <url>/2020/08/14/csp-j2019%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>这是我参加的第一场noip考试，却因为种种原因，变成了csp比赛，2020年又变回了noip。</p>
<h2 id="T1-数字游戏"><a href="#T1-数字游戏" class="headerlink" title="T1 数字游戏"></a>T1 数字游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 K 同学向小 P 同学发送了一个长度为 8 的 <strong>01 字符串</strong>来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 1。</p>
<p>注意：01 字符串为每一个字符是 0 或者 1 的字符串，如“101”（不含双引号）为一个长度为 3 的 01 字符串。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件只有一行，一个长度为 8 的 01 字符串 s。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件只有一行，包含一个整数，即 01 字符串中<strong>字符 1</strong> 的个数。</p>
<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">00010100</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>【输入输出样例 1 说明】</p>
<p>该 01 字符串中有 2 个字符 1。</p>
<p>【输入输出样例 2 说明】</p>
<p>该 01 字符串中有 8 个字符 1。</p>
<p>【数据规模与约定】</p>
<p>对于 20% 的数据，保证输入的字符全部为 0。</p>
<p>对于 100% 的数据，输入只可能包含字符 0 和字符 1，字符串长度固定为 8。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>签到题，可以使用字符串相关知识解决</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("number.in","r",stdin);</span></span><br><span class="line">	<span class="comment">//freopen("number.out","w",stdout);</span></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)</span><br><span class="line">			ans++;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2-公交换乘"><a href="#T2-公交换乘" class="headerlink" title="T2 公交换乘"></a>T2 公交换乘</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：</p>
<ol>
<li>在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：<script type="math/tex">t_{bus} - t_{subway} \leq 45</script></li>
<li>搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。</li>
<li>搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。</li>
</ol>
<p>现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件的第一行包含一个正整数 n，代表乘车记录的数量。</p>
<p>接下来的 n 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。第 i 行的第 1 个整数代表第 i 条记录乘坐的交通工具，0 代表地铁，1 代表公交车；第 2 个整数代表第 i 条记录乘车的票价 <script type="math/tex">price_i</script> ；第三个整数代表第 i<em>i</em> 条记录开始乘车的时间 <script type="math/tex">t_i</script>（距 0 时刻的分钟数）。</p>
<p>我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件有一行，包含一个正整数，代表小轩出行的总花费。</p>
<h3 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">46</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">12</span> <span class="number">50</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">96</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">5</span> <span class="number">110</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">6</span> <span class="number">135</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">20</span> <span class="number">16</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">7</span> <span class="number">23</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">18</span> <span class="number">31</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span> <span class="number">38</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">7</span> <span class="number">68</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="说明-提示-1"><a href="#说明-提示-1" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>【输入输出样例 1 说明】</p>
<p>第一条记录，在第 3 分钟花费 10 元乘坐地铁。</p>
<p>第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。</p>
<p>第三条记录，在第 50 分种花费 12 元乘坐地铁。</p>
<p>第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。</p>
<p>第五条记录，在第 110 分钟花费 5 元乘坐地铁。</p>
<p>第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。</p>
<p>总共花费 36 元。</p>
<p>【输入输出样例 2 说明】</p>
<p>第一条记录，在第 1 分钟花费 5 元乘坐地铁。</p>
<p>第二条记录，在第 16 分钟花费 20 元乘坐地铁。</p>
<p>第三条记录，在第 23 分钟花费 7 元乘坐地铁。</p>
<p>第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。</p>
<p>第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。</p>
<p>第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。</p>
<p>总共花费 32 元。</p>
<p>【数据规模与约定】</p>
<p>对于 30% 的数据，<script type="math/tex">n \leq 1000，t_i \leq 10^6</script>。</p>
<p>另有 15% 的数据，<script type="math/tex">t_i \leq 10^7，price_i</script> 都相等。</p>
<p>另有 15% 的数据，<script type="math/tex">t_i \leq 10^9，price_i</script> 都相等。</p>
<p>对于 100% 的数据，<script type="math/tex">n \leq 10^5，t_i \leq 10^9，1 \leq price_i \leq 1000</script>。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>队列+模拟</p>
<p>每次把first移到没超时的地铁票那里</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> price,t;</span><br><span class="line">	<span class="keyword">bool</span> flag;</span><br><span class="line">&#125;q[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("transfer.in","r",stdin);</span></span><br><span class="line">	<span class="comment">//freopen("transfer.out","w",stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n,ans=<span class="number">0</span>,first=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag;</span><br><span class="line">		<span class="keyword">int</span> price,t;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;flag&gt;&gt;price&gt;&gt;t;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=price;</span><br><span class="line">			q[last].price=price;</span><br><span class="line">			q[last].t=t+<span class="number">45</span>;</span><br><span class="line">			q[last].flag=<span class="number">0</span>;</span><br><span class="line">			last++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(q[first].t&lt;t &amp;&amp; first&lt;last)</span><br><span class="line">				first++;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=first;j&lt;last;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(q[j].price&gt;=price &amp;&amp; q[j].flag==<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					q[j].flag=<span class="number">1</span>;</span><br><span class="line">					ans-=price;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=price;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3-纪念品"><a href="#T3-纪念品" class="headerlink" title="T3 纪念品"></a>T3 纪念品</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>小伟突然获得一种超能力，他知道未来 T 天 N 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。</p>
<p>每天，小伟可以进行以下两种交易<strong>无限次</strong>：</p>
<ol>
<li>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；</li>
<li>卖出持有的任意一个纪念品，以当日价格换回金币。</li>
</ol>
<p>每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。</p>
<p>T 天之后，小伟的超能力消失。因此他一定会在第 T 天卖出<strong>所有</strong>纪念品换回金币。</p>
<p>小伟现在有 M 枚金币，他想要在超能力消失后拥有尽可能多的金币。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含三个正整数 T, N, M，相邻两数之间以一个空格分开，分别代表未来天数 T，纪念品数量 N，小伟现在拥有的金币数量 M。</p>
<p>接下来 T行，每行包含 N个正整数，相邻两数之间以一个空格分隔。第 i 行的 N 个正整数分别为 <script type="math/tex">P，P_{i,2},……,P_{i,N}</script>，其中 <script type="math/tex">P_{i,j}</script> 表示第 i 天第 j 种纪念品的价格。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。</p>
<h3 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">6 </span><span class="number">1</span> <span class="number">100</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">305</span></span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">20</span> <span class="number">15</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">17</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">25</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">217</span></span><br></pre></td></tr></table></figure>
<h3 id="说明-提示-2"><a href="#说明-提示-2" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>【输入输出样例 1 说明】</p>
<p>最佳策略是：</p>
<p>第二天花光所有 100 枚金币买入 5 个纪念品 1；</p>
<p>第三天卖出 5 个纪念品 1，获得金币 125 枚；</p>
<p>第四天买入 6 个纪念品 1，剩余 5 枚金币；</p>
<p>第六天必须卖出所有纪念品换回 300 枚金币，第四天剩余 5 枚金币,共 305 枚金币。</p>
<p>超能力消失后，小伟最多拥有 305 枚金币。</p>
<p>【输入输出样例 2 说明】</p>
<p>最佳策略是：</p>
<p>第一天花光所有金币买入 10 个纪念品 1；</p>
<p>第二天卖出全部纪念品 1 得到 150 枚金币并买入 8 个纪念品 2 和 1 个纪念品 3，剩余 1 枚金币；</p>
<p>第三天必须卖出所有纪念品换回216 枚金币，第二天剩余1枚金币，共 217 枚金币。</p>
<p>超能力消失后，小伟最多拥有 217 枚金币。</p>
<p>【数据规模与约定】</p>
<p>对于 10% 的数据，<script type="math/tex">T = 1</script>。</p>
<p>对于 30% 的数据，<script type="math/tex">T \leq 4, N \leq 4, M \leq 100</script>，所有价格 <script type="math/tex">10 \leq P_{i,j} \leq 100</script>。</p>
<p>另有 15% 的数据，<script type="math/tex">T \leq 100, N = 1</script>。</p>
<p>另有 15% 的数据，<script type="math/tex">T = 2, N \leq 100</script>。</p>
<p>对于 100% 的数据，<script type="math/tex">T \leq 100, N \leq 100, M \leq 10^3</script>，所有价格 <script type="math/tex">1 \leq P_{i,j} \leq 10^4</script>，数据保证任意时刻，小明手上的金币数不可能超过 <script type="math/tex">10^4</script>。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>可以看出来这是一个动态规划的问题，我们可以用dp[i] [j]代表在第i天时有j块钱时第二天最多可以得多少钱，但是可以压缩掉天数的一维</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">110</span>][<span class="number">110</span>],dp[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("souvenir.in","r",stdin);</span></span><br><span class="line">	<span class="comment">//freopen("souvenir.out","w",stdout);</span></span><br><span class="line">	<span class="keyword">int</span> t,n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10000</span>;j++)</span><br><span class="line">			dp[j]=<span class="number">-10010</span>;</span><br><span class="line">		dp[m]=m; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&gt;=p[i][j];k--)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[k-p[i][j]]=max(dp[k-p[i][j]],dp[k]+p[i+<span class="number">1</span>][j]-p[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> maxm=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			maxm=max(maxm,dp[j]);</span><br><span class="line">		m=maxm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T4-加工零件"><a href="#T4-加工零件" class="headerlink" title="T4 加工零件"></a>T4 加工零件</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 n 位工人，工人们从 <script type="math/tex">1 \sim n</script> 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。</p>
<p>如果 x 号工人想生产一个被加工到第 <script type="math/tex">L (L \gt 1)</script> 阶段的零件，则<strong>所有</strong>与 x 号工人有传送带<strong>直接</strong>相连的工人，都需要生产一个被加工到第 L - 1 阶段的零件（但 x 号工人自己<strong>无需</strong>生产第 L - 1 阶段的零件）。</p>
<p>如果 x 号工人想生产一个被加工到第 1 阶段的零件，则<strong>所有</strong>与 x 号工人有传送带<strong>直接</strong>相连的工人，都需要为 x 号工人提供一个原材料。</p>
<p>轩轩是 1 号工人。现在给出 q 张工单，第 i 张工单表示编号为 <script type="math/tex">a_i</script> 的工人想生产一个第 <script type="math/tex">L_i</script> 阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！</p>
<h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行三个正整数 n，m 和 q，分别表示工人的数目、传送带的数目和工单的数目。</p>
<p>接下来 m 行，每行两个正整数 u 和 v，表示编号为 u 和 v 的工人之间存在一条零件传输带。保证 <script type="math/tex">u \neq v</script>。</p>
<p>接下来 q 行，每行两个正整数 a 和 L，表示编号为 a 的工人想生产一个第 L 阶段的零件。</p>
<h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h3><p>共 q 行，每行一个字符串 <code>Yes</code> 或者 <code>No</code>。如果按照第 i 张工单生产，需要编号为 1 的轩轩提供原材料，则在第 i 行输出 <code>Yes</code>；否则在第 i 行输出 <code>No</code>。注意输出<strong>不含</strong>引号。</p>
<h3 id="输入输出样例-3"><a href="#输入输出样例-3" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">No</span></span><br><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="literal">No</span></span><br><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="literal">No</span></span><br><span class="line"><span class="literal">Yes</span></span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">No</span></span><br><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="literal">No</span></span><br><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="literal">Yes</span></span><br></pre></td></tr></table></figure>
<h3 id="说明-提示-3"><a href="#说明-提示-3" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>【输入输出样例 1 说明】</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png" alt="img"></p>
<p>编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。</p>
<p>编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。</p>
<p>编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。</p>
<p>编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零 件，需要编号为 1 和 3 的工人提供原材料。</p>
<p>编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。</p>
<p>编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。</p>
<p>【输入输出样例 2 说明】</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png" alt="img"></p>
<p>编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。</p>
<p>编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。</p>
<p>编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。</p>
<p>编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。</p>
<p>编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。</p>
<p>【数据规模与约定】</p>
<p>共 20 个测试点。</p>
<p><script type="math/tex">1 \leq u, v, a \leq n</script>。</p>
<p>测试点 1~4，<script type="math/tex">1 \leq n, m \leq 1000，q = 3</script>。</p>
<p>测试点 5~8，<script type="math/tex">1 \leq n, m \leq 1000，q = 3，1 \leq L \leq 10</script>。</p>
<p>测试点 9~12，<script type="math/tex">1 \leq n, m, L \leq 1000，1 \leq q \leq 100</script>。</p>
<p>测试点 13~16，<script type="math/tex">1 \leq n, m, L \leq 1000，1 \leq q \leq 10^5</script>。</p>
<p>测试点 17~20，<script type="math/tex">1 \leq n, m, q \leq 10^5，1 \leq L \leq 10^9</script>。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>可以发现这道题的本质时求一遍奇数最短路径和偶数最短路径</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num,dis;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.dis&lt;dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,q,head[N],cnt,w[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N][<span class="number">2</span>];</span><br><span class="line">priority_queue&lt;node&gt; pq;</span><br><span class="line">edge e[N];</span><br><span class="line">node qtemp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">	e[cnt].to=v;</span><br><span class="line">	e[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		qtemp=pq.top();</span><br><span class="line">		pq.pop();</span><br><span class="line">		<span class="keyword">int</span> now=qtemp.num;</span><br><span class="line">		i=head[now];</span><br><span class="line">		<span class="keyword">while</span>(i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tempto=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(w[tempto][<span class="number">0</span>]&gt;w[now][<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				w[tempto][<span class="number">0</span>]=w[now][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(!vis[tempto][<span class="number">0</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					vis[tempto][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">					qtemp.num=tempto;</span><br><span class="line">					qtemp.dis=w[tempto][<span class="number">0</span>];</span><br><span class="line">					pq.push(qtemp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(w[tempto][<span class="number">1</span>]&gt;w[now][<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				w[tempto][<span class="number">1</span>]=w[now][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(!vis[tempto][<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					vis[tempto][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">					qtemp.num=tempto;</span><br><span class="line">					qtemp.dis=w[tempto][<span class="number">1</span>];</span><br><span class="line">					pq.push(qtemp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			i=e[i].next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("work.in","r",stdin);</span></span><br><span class="line">	<span class="comment">//freopen("work.out","w",stdout);</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add_edge(u,v);</span><br><span class="line">		add_edge(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		w[i][<span class="number">0</span>]=<span class="number">2000000</span>;</span><br><span class="line">		w[i][<span class="number">1</span>]=<span class="number">2000000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	w[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	qtemp.num=<span class="number">1</span>;</span><br><span class="line">	qtemp.dis=<span class="number">0</span>;</span><br><span class="line">	pq.push(qtemp);</span><br><span class="line">	dijkstra();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> a,l;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;l;</span><br><span class="line">		<span class="keyword">if</span>(!head[<span class="number">1</span>])</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(w[a][l%<span class="number">2</span>]&lt;=l)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>noip</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>一元二次方程新解法</title>
    <url>/2020/07/28/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%96%B0%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p>近日，美国国家奥数队总教练总教练、卡耐基梅隆数学大学教授罗博深表示，刚刚发现了一种最新的二次方程求根公式推导技巧。为求解一般二次方程式提供了一种高效自然的方法。该推导在计算上是轻量级的，大大缩减了求根公式的复杂性，并且在概念上是自然的。<br>此方程的解法运用到了韦达定理，所以在此先将韦达定理说一下</p>
<a id="more"></a>
<h2 id="1-韦达定理"><a href="#1-韦达定理" class="headerlink" title="1.韦达定理"></a>1.韦达定理</h2><p>法国数学家弗朗索瓦·韦达于1615年在著作《论方程的识别与订正》中建立了方程根与系数的关系，提出了这条定理。 由于韦达最早发现代数方程的根与系数之间有这种关系，人们把这个关系称为韦达定理。</p>
<blockquote>
<pre><code>  韦达定理就是说明了高次方程中根与系数的关系
</code></pre><h3 id="在一元二次方程中根与系数关系"><a href="#在一元二次方程中根与系数关系" class="headerlink" title="在一元二次方程中根与系数关系"></a>在一元二次方程中根与系数关系</h3><p>设一元二次方程$ax^2+bx+c=0(a\neq 0)$两根为$x_1,x_2$，两根有如下关系</p>
<script type="math/tex; mode=display">x_1+x_2=-\dfrac{b}{a}</script><script type="math/tex; mode=display">x_1x_2=\dfrac{c}{a}</script><p>可以用多种方法推出关系</p>
<h4 id="证法1"><a href="#证法1" class="headerlink" title="证法1"></a>证法1</h4><p>可以根据一元二次方程的求根公式求出关系，设$x_1&lt;x_2$，则</p>
</blockquote>
<p>$x_1=\dfrac{-b-\sqrt{b^2-4ac}}{2a},x_2=\dfrac{-b+\sqrt{b^2-4ac}}{2a}$</p>
<p>将$x_1$加上$x_2$得</p>
<p>$x_1+x_2=\dfrac{-b-\sqrt{b^2-4ac}}{2a}+\dfrac{-b+\sqrt{b^2-4ac}}{2a}=\dfrac{-2b}{2a}=-\dfrac{b}{a}$</p>
<p>将$x_1$乘上$x_2$得</p>
<p>$x_1x_2=\dfrac{-b-\sqrt{b^2-4ac}}{2a}\cdot\dfrac{-b+\sqrt{b^2-4ac}}{2a}=\dfrac{b^2-\left(b^2-4ac\right)}{4a^2}=\dfrac{4ac}{4a^2}=\dfrac{c}{a}$</p>
<p>综上</p>
<p>$\begin{cases} x_1+x_2=-\dfrac{b}{a}\\\\x_1x_2=\dfrac{c}{a}\end{cases}$</p>
<h4 id="证法2"><a href="#证法2" class="headerlink" title="证法2"></a>证法2</h4><p>可以根据一元二次方程的因式分解求出关系，</p>
<p>因为由因式定理可得$(x-x_1),(x-x_2)$均为一元二次方程$ax^2+bx+c=0(a\neq 0)$的因式</p>
<p>所以</p>
<p>$ax^2+bx+c=a(x-x_1)(x-x_2)=0$</p>
<p>将它乘开，得</p>
<p>$a(x-x_1)(x-x_2)=ax^2-a(x_1+x_2)x+ax_1x_2=0$</p>
<p>又</p>
<p>$ax^2+bx+c=0$</p>
<p>所以</p>
<p>$\begin{cases} x_1+x_2=-\dfrac{b}{a}\\\\x_1x_2=\dfrac{c}{a}\end{cases}$</p>
<h4 id="逆定理"><a href="#逆定理" class="headerlink" title="逆定理"></a>逆定理</h4><p>若两数p,q，满足$p+q=-\dfrac{b}{a},pq=\dfrac{c}{a}$,那么p,q为方程$ax^2+bx+c=0$的两根，特殊的，若a=1,则p,q为方程$x^2-(p+q)x+pq=0$的两根</p>
<h3 id="高次方程中根与系数关系"><a href="#高次方程中根与系数关系" class="headerlink" title="高次方程中根与系数关系"></a>高次方程中根与系数关系</h3><p>代数基本定理：任何复系数一元n次多项式方程在复数域上至少有一根(n≥1)，由此推出，n次复系数多项式方程在复数域内有且只有n个根<br>由代数基本定理可知，高次方程</p>
<script type="math/tex; mode=display">a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0=0(a_n\neq 0)</script><p>有n个根（相同的根按不同根计算）<br>设方程$a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0=0(a_n\neq 0)$的n个根为$x_1,x_2\cdots x_{n-1},x_n$<br>方程$a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0=0(a_n\neq 0)$的根与系数满足</p>
<script type="math/tex; mode=display">x_1+x_2+x_3+\cdots+x_n=-\dfrac{a_{n-1}}{a_n}</script><script type="math/tex; mode=display">x_1x_2+x_1x_3+x_1x_4+\cdots+x_{n-1}x_n=\dfrac{a_{n-2}}{a_n}</script><script type="math/tex; mode=display">x_1x_2x_3+x_1x_2x_4+x_1x_2x_5+\cdots+x_{n-2}x_{n-1}x_n=-\dfrac{a_{n-3}}{a_n}</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">x_1x_2x_3\cdots x_n=\left(-1\right)^n\cdot\dfrac{a_0}{a_n}</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>因为由因式定理可得$(x-x_1),(x-x_2)\cdots,(x-x_n)$均为多项式$a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0$的因式</p>
<p>所以多项式$a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0$可以因式分解为</p>
<script type="math/tex; mode=display">a_n(x-x_1)(x-x_2)\cdots(x-x_n)</script><p>展开后得</p>
<p>$a_nx^n-a_n\left(x_1+x_2+\cdots+x_n\right)x^{n-1}+a_n\left(x_1x_2+x_1x_3+\cdots+x_{n-1}x_n\right)x^{n-2}+\cdots+\left(-1\right)^na_nx_1x_2\cdots x_n$</p>
<p>可以对比多项式$a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0$各项系数，所以可得</p>
<script type="math/tex; mode=display">x_1+x_2+x_3+\cdots+x_n=-\dfrac{a_{n-1}}{a_n}</script><script type="math/tex; mode=display">x_1x_2+x_1x_3+x_1x_4+\cdots+x_{n-1}x_n=\dfrac{a_{n-2}}{a_n}</script><script type="math/tex; mode=display">x_1x_2x_3+x_1x_2x_4+x_1x_2x_5+\cdots+x_{n-2}x_{n-1}x_n=-\dfrac{a_{n-3}}{a_n}</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">x_1x_2x_3\cdots x_n=\left(-1\right)^n\cdot\dfrac{a_0}{a_n}</script><p>也就是高次韦达定理</p>
<h2 id="2-一元二次方程传统解法"><a href="#2-一元二次方程传统解法" class="headerlink" title="2.一元二次方程传统解法"></a>2.一元二次方程传统解法</h2><h3 id="因式分解法"><a href="#因式分解法" class="headerlink" title="因式分解法"></a>因式分解法</h3><p>将一元二次方程$ax^2+bx+c=0$进行因式分解，求解出方程的根，通常不进行非整数的因式分解，最基本的条件是$\Delta$为完全平方数时</p>
<h3 id="配方法"><a href="#配方法" class="headerlink" title="配方法"></a>配方法</h3><p>将$ax^2+bx+c$配成完全平方公式，再将等式两边同时开根号，化为一次方程进行求解，配方法适用于所有有根的一元二次方程</p>
<h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>因为配方法适用于所有一元二次方程，所以可以通过一元二次方程的一般形式来配方，最终得出求根公式</p>
<script type="math/tex; mode=display">ax^2+bx+c=0</script><script type="math/tex; mode=display">\downarrow</script><script type="math/tex; mode=display">ax^2+bx=-c</script><script type="math/tex; mode=display">\downarrow</script><script type="math/tex; mode=display">x^2+\dfrac{b}{a}x=-\dfrac{c}{a}</script><script type="math/tex; mode=display">\downarrow</script><script type="math/tex; mode=display">x^2+\dfrac{b}{a}x+\left(\dfrac{b}{2a}\right)^2=-\dfrac{c}{a}+\left(\dfrac{b}{2a}\right)^2</script><script type="math/tex; mode=display">\downarrow</script><script type="math/tex; mode=display">\left(x+\dfrac{b}{2a}\right)^2=\dfrac{b^2-4ac}{4a^2}</script><script type="math/tex; mode=display">\because a\neq 0 \therefore 4a^2>0,讨论b^2-4ac</script><script type="math/tex; mode=display">(1)b^2-4ac>0</script><script type="math/tex; mode=display">x_{1,2}=\dfrac{-b\pm\sqrt{b^2-4ac}}{2a}</script><script type="math/tex; mode=display">(2)b^2-4ac=0</script><script type="math/tex; mode=display">x_1=x_2=-\dfrac{b}{2a}</script><script type="math/tex; mode=display">(3)b^2-4ac<0</script><script type="math/tex; mode=display">方程无实根</script><p>公式<script type="math/tex">x_{1,2}=\dfrac{-b\pm\sqrt{b^2-4ac}}{2a}</script>就被称为求根公式</p>
<h3 id="图像法"><a href="#图像法" class="headerlink" title="图像法"></a>图像法</h3><p>画出二次函数$y=ax^2+bx+c$的图像，找到零点进行求解，可以运用二分法求零点的近似解</p>
<h2 id="3-一元二次方程新解法"><a href="#3-一元二次方程新解法" class="headerlink" title="3.一元二次方程新解法"></a>3.一元二次方程新解法</h2><p>这种解法不同于以往的解法，更像是解一元二次方程的一种小技巧</p>
<p>设一元二次方程$ax^2+bx+c=0$两根为$x_1,x_2(x_1&lt;x_2)$</p>
<p>由韦达定理可知</p>
<script type="math/tex; mode=display">x_1+x_2=-\dfrac{b}{a}</script><script type="math/tex; mode=display">x_1x_2=\dfrac{c}{a}</script><p>取$x_1,x_2$的平均值</p>
<script type="math/tex; mode=display">\dfrac{x_1+x_2}{2}=-\dfrac{b}{2a}</script><p>设两根分别为$x_1=-\dfrac{b}{2a}-t,x_2=-\dfrac{b}{2a}+t$</p>
<p>将$x_1\cdot x_2$得</p>
<p>$\left(-\dfrac{b}{2a}-t\right)\left(-\dfrac{b}{2a}+t\right)=\dfrac{c}{a}$</p>
<p>等式左边可以化为平方差公式</p>
<p>$\left(-\dfrac{b}{2a}\right)^2-t^2=\dfrac{c}{a}$</p>
<p>容易得到t的值</p>
<p>$t=\sqrt{\left(-\dfrac{b}{2a}\right)^2-\dfrac{c}{a}}$</p>
<p>可以得到$x_1,x_2$的值</p>
<p>其实这也只是求根公式的一种变形，但在过程上大大缩减了求根公式的复杂性</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>根式</tag>
      </tags>
  </entry>
  <entry>
    <title>三分法</title>
    <url>/2020/07/28/%E4%B8%89%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>顾名思义，三分法就是把一个区间分成三份（不一定等分），可以用来求某一区间的最值</p>
<a id="more"></a>
<h2 id="P3382-【模板】三分法"><a href="#P3382-【模板】三分法" class="headerlink" title="P3382 【模板】三分法"></a>P3382 【模板】三分法</h2><p><a href="https://www.luogu.com.cn/problem/P3382" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，给出一个 N 次函数，保证在范围 [l, r] 内存在一点 xx，使得 [l, x] 上单调增，[x, r] 上单调减。试求出 x 的值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一次包含一个正整数 N 和两个实数 l, r，含义如题目描述所示。<br>第二行包含 N + 1 个实数，从高到低依次表示该 N 次函数各项的系数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出为一行，包含一个实数，即为 x 的值。四舍五入保留 5 位小数。</p>
<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>3 -0.9981 0.5<br>1 -3 -3 1</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>-0.41421</p>
<h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>对于 100% 的数据，7 $\le$ N $\le$ 137 $\le$ N $\le$ 13。</p>
<h4 id="【样例解释】"><a href="#【样例解释】" class="headerlink" title="【样例解释】"></a>【样例解释】</h4><p><img src="file://C:/Users/Think/Documents/Gridea/post-images/1583037098692.png" alt=""><br>如图所示，红色段即为该函数 f(x) = x^3 - 3 x^2 - 3x + 1f(x)=x<br>3<br> −3x<br>2<br> −3x+1 在区间 [-0.9981, 0.5][−0.9981,0.5] 上的图像。</p>
<p>当 x = -0.41421x=−0.41421 时图像位于最高点，故此时函数在 [l, x][l,x] 上单调增，[x, r][x,r] 上单调减，故 x = -0.41421x=−0.41421，输出 -0.41421−0.41421。</p>
<p>（Tip.l和r的范围并不是非常大不会超过一位数）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(x,k<span class="number">-1</span>)*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		ans+=a[i]*<span class="built_in">pow</span>(x,i);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sanfen</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r || r-l&lt;<span class="number">0.000001</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">double</span> midl,midr;</span><br><span class="line">	midl=(l+r)/<span class="number">2</span>;</span><br><span class="line">	midr=(midl+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">double</span> fmidl=f(midl),fmidr=f(midr);</span><br><span class="line">	<span class="keyword">if</span>(fmidl&gt;fmidr)</span><br><span class="line">		<span class="keyword">return</span> sanfen(l,midr);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> sanfen(midl,r);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">double</span> l,r;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="keyword">for</span>(i=n;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">double</span> ans=sanfen(l,r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.5lf"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1883-函数"><a href="#P1883-函数" class="headerlink" title="P1883 函数"></a>P1883 函数</h2><p><a href="https://www.luogu.com.cn/problem/P1883" target="_blank" rel="noopener">题目传送门</a></p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 nn 个二次函数 $f_1(x),f_2(x),\dots,f_n(x)$<br>（均形如 ax^2+bx+c），设 $F(x)=\max\{f_1(x),f_2(x),…,f_n(x)\}$，求 F(x) 在区间 [0,1000] 上的最小值。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行为正整数 T，表示有 T 组数据。<br>每组数据第一行一个正整数 n，接着 n 行，每行 3 个整数 a,b,c，用来表示每个二次函数的 3 个系数，注意二次函数有可能退化成一次。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组数据输出一行，表示 F(x) 的在区间 [0,1000] 上的最小值。答案精确到小数点后四位，四舍五入。</p>
<h3 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>2<br>1<br>2 0 0<br>2<br>2 0 0<br>2 -4 2</p>
<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>0.0000<br>0.5000</p>
<h3 id="说明-提示-1"><a href="#说明-提示-1" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>对于 50% 的数据，$n\le 100$</p>
<p>对于 100% 的数据，$T&lt;10，\ n\le 10^4 ，0\le a\le 100，|b| \le 5\times 10^3，|c| \le 5\times 10^3$</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> ans=a[<span class="number">1</span>].a*x*x+a[<span class="number">1</span>].b*x+a[<span class="number">1</span>].c,sum;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=a[i].a*x*x+a[i].b*x+a[i].c;</span><br><span class="line">		ans=max(sum,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sanfen</span><span class="params">(<span class="keyword">double</span> l,<span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r || r-l&lt;=<span class="number">1e-11</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">double</span> midl,midr;</span><br><span class="line">	midl=(l+r)/<span class="number">2</span>;</span><br><span class="line">	midr=(midl+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">double</span> fmidl=f(midl),fmidr=f(midr);</span><br><span class="line">	<span class="keyword">if</span>(fmidl&gt;fmidr)</span><br><span class="line">		<span class="keyword">return</span> sanfen(midl,r);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> sanfen(l,midr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t,i;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].c;</span><br><span class="line">		<span class="keyword">double</span> ans=sanfen(<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,f(ans));</span><br><span class="line">		t--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>noip提高组专题复习1-枚举</title>
    <url>/2020/07/26/noip%E6%8F%90%E9%AB%98%E7%BB%84%E4%B8%93%E9%A2%98%E5%A4%8D%E4%B9%A01-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>本文章有4道枚举的经典例题</p>
<a id="more"></a>
<h2 id="Flip-Game-poj-1753"><a href="#Flip-Game-poj-1753" class="headerlink" title="Flip Game poj-1753"></a>Flip Game <a href="http://poj.org/problem?id=1753" target="_blank" rel="noopener">poj-1753</a></h2><p>题意：给你一个4*4的黑白棋盘,每次可以将一个棋子反转颜色,同时这个棋子的上下左右都会反转,问你最少反转几次,可以将整个棋盘变成同色的无解输出Impossible<br>题解：可以通过dfs暴力枚举得出答案；可以状态压缩，用二进制枚举，枚举出怎么翻的所有情况，求出答案</p>
<p>dfs代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路： </span></span><br><span class="line"><span class="comment">暴力dfs</span></span><br><span class="line"><span class="comment">每个格子最多翻一次 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> tx[<span class="number">7</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,ty[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,ans=<span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">//翻第x行y列的棋子以及上下左右的棋子 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> newx=x+tx[i],newy=y+ty[i];</span><br><span class="line">		<span class="keyword">if</span>(newx&gt;=<span class="number">0</span> &amp;&amp; newx&lt;<span class="number">4</span> &amp;&amp; newy&gt;=<span class="number">0</span> &amp;&amp; newy&lt;<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[newx][newy]==<span class="string">'b'</span>)</span><br><span class="line">				g[newx][newy]=<span class="string">'w'</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g[newx][newy]=<span class="string">'b'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> <span class="comment">//检查是否全部同色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">char</span> f=g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[i][j]!=f)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> t)</span> <span class="comment">//dfs枚举 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">16</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">			ans=min(ans,step);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x=t/<span class="number">4</span>,y=t%<span class="number">4</span>;</span><br><span class="line">	change(x,y);</span><br><span class="line">	dfs(step+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">	change(x,y);</span><br><span class="line">	dfs(step,t+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;g[i];</span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">200</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二进制枚举代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路： </span></span><br><span class="line"><span class="comment">用二进制位运算来状态压缩</span></span><br><span class="line"><span class="comment">1表示翻，0表示不翻，所以翻不翻的所有情况都可以通过二进制枚举出来 </span></span><br><span class="line"><span class="comment">0000=0</span></span><br><span class="line"><span class="comment">0001=1</span></span><br><span class="line"><span class="comment">0010=2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">1111=15</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">与运算 &amp;</span></span><br><span class="line"><span class="comment">同为一才为一 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> tx[<span class="number">7</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,ty[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,ans=<span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j)</span> <span class="comment">//翻第j/4行j%4列的棋子以及上下左右的棋子 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,x=j/<span class="number">4</span>,y=j%<span class="number">4</span>; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> newx=x+tx[i],newy=y+ty[i];</span><br><span class="line">		<span class="keyword">if</span>(newx&gt;=<span class="number">0</span> &amp;&amp; newx&lt;<span class="number">4</span> &amp;&amp; newy&gt;=<span class="number">0</span> &amp;&amp; newy&lt;<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[newx][newy]==<span class="string">'b'</span>)</span><br><span class="line">				g[newx][newy]=<span class="string">'w'</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g[newx][newy]=<span class="string">'b'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> <span class="comment">//检查是否全部同色 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">char</span> f=g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[i][j]!=f)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;g[i];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="number">1</span> &lt;&lt; <span class="number">16</span>);i++) <span class="comment">//枚举所有翻的情况 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> step=<span class="number">0</span>; <span class="comment">//走了几步 </span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="comment">//判断第j位为是否为1</span></span><br><span class="line">			&#123;</span><br><span class="line">				change(j);</span><br><span class="line">				step++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">			ans=min(ans,step);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="comment">//判断第j位为是否为1</span></span><br><span class="line">				change(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">200</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subsequence-UVA-1121"><a href="#Subsequence-UVA-1121" class="headerlink" title="Subsequence UVA-1121"></a>Subsequence <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3562" target="_blank" rel="noopener">UVA-1121</a></h2><p>题意：给你n和S以及n个数,求最短的连续子序列的长度使得这个连续子序列的和大于等于S，无解输出0<br>题解：预处理前缀和sum[i]=前i个数的和，二分枚举最小符合条件的右端点，找出最小的答案，否则输出0</p>
<p>二分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">二分，预处理前缀和sum[i]=前i个数的和，二分枚举最小符合条件的右端点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,s,a,sum[<span class="number">100050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">100010</span>;</span><br><span class="line">		sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">			sum[i]=sum[i<span class="number">-1</span>]+a; <span class="comment">//前缀和 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> l=i,r=n,best=<span class="number">0</span>; <span class="comment">//二分右端点 </span></span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(sum[mid]-sum[i<span class="number">-1</span>]&gt;=s)</span><br><span class="line">				&#123;</span><br><span class="line">					best=mid;</span><br><span class="line">					r=mid<span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(best!=<span class="number">0</span>)</span><br><span class="line">				ans=min(ans,best-i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">100010</span>)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/syntaxhighlight&gt;</span><br><span class="line">尺取法代码：</span><br><span class="line">&lt;syntaxhighlight lang=<span class="string">"C++"</span> line&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">尺取法，可以发现第i+1个数最小符合条件的右端点一定大于第i个数最小符合条件的右端点，</span></span><br><span class="line"><span class="comment">所以可以存储上一个数最小符合条件的右端点，从这个点开始枚举，复杂度O(n) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,s,a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">100010</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>,sum=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(j+<span class="number">1</span>&lt;=n &amp;&amp; sum&lt;s)</span><br><span class="line">			&#123;</span><br><span class="line">				sum+=a[j+<span class="number">1</span>];</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;=s)</span><br><span class="line">				ans=min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">			sum-=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">100010</span>)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Xor-Sum-2-AtCoder-arc098-b"><a href="#Xor-Sum-2-AtCoder-arc098-b" class="headerlink" title="Xor Sum 2 AtCoder - arc098_b"></a>Xor Sum 2 <a href="https://vjudge.net/problem/AtCoder-arc098_b/origin" target="_blank" rel="noopener">AtCoder - arc098_b</a></h2><p>题意：求有多少区间的xor之和等于区间的数的和<br>题解：尺取法，可以发现第i+1个数最小符合条件的右端点一定大于第i个数最小符合条件的右端点，<br>所以可以存储上一个数最小符合条件的右端点，从这个点开始枚举<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">尺取法，可以发现第i+1个数最小符合条件的右端点一定大于第i个数最小符合条件的右端点，</span></span><br><span class="line"><span class="comment">所以可以存储上一个数最小符合条件的右端点，从这个点开始枚举 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">300100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,i;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">0</span>,suma=<span class="number">0</span>,sumb=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j+<span class="number">1</span>&lt;=n &amp;&amp; (suma^a[j+<span class="number">1</span>])==sumb+a[j+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			suma^=a[j+<span class="number">1</span>];</span><br><span class="line">			sumb+=a[j+<span class="number">1</span>];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=j-i+<span class="number">1</span>; </span><br><span class="line">		suma^=a[i];</span><br><span class="line">		sumb-=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maximum-Subsequence-CodeForces-888E"><a href="#Maximum-Subsequence-CodeForces-888E" class="headerlink" title="Maximum Subsequence CodeForces - 888E"></a>Maximum Subsequence <a href="https://vjudge.net/problem/CodeForces-888E/origin" target="_blank" rel="noopener">CodeForces - 888E</a></h2><p>题意：给你最多35个整数, 选出一个子集使得这个子集的和取余m最大,求最大的余数<br>题解：折半枚举，把数组分成两半，分成两半后，暴力枚举前一半的组合，保存在b[]，<br>进行排序，复杂度最多为2^18，枚举完后，再暴力枚举另一半的所有组合，在<br>前一半的组合里寻找一个数，使这个数与一个组合加起来模m最大（在b数组中<br>查找小于等于m-1-x的最大的数，如果不存在取最大的数）<br>问题变成了在有序数组中查找一个数，二分解决<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">折半枚举，把数组分成两半，分成两半后，暴力枚举前一半的组合，保存在b[]，</span></span><br><span class="line"><span class="comment">进行排序，复杂度最多为2^18，枚举完后，再暴力枚举另一半的所有组合，在</span></span><br><span class="line"><span class="comment">前一半的组合里寻找一个数，使这个数与一个组合加起来模m最大（在b数组中</span></span><br><span class="line"><span class="comment">查找小于等于m-1-x的最大的数，如果不存在取最大的数）</span></span><br><span class="line"><span class="comment">问题变成了在有序数组中查找一个数，二分解决 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">40</span>],b[<span class="number">262200</span>],temp=<span class="number">0</span>,n,m,i,j,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=temp<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(b[mid]&gt;x)</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i]%=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n/<span class="number">2</span>));i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">			&#123;</span><br><span class="line">				sum=(sum+a[j])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		b[temp++]=sum;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(b,b+temp);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-(n/<span class="number">2</span>)));i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;(n-(n/<span class="number">2</span>));j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">			&#123;</span><br><span class="line">				sum=(sum+a[j+(n/<span class="number">2</span>)])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> x=find(m-sum<span class="number">-1</span>);</span><br><span class="line">		ans=max(ans,(b[x]+sum)%m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>noip提高组</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>使用位运算解决n皇后问题</title>
    <url>/2020/07/26/%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(皇后可以攻击在同一条斜线或直线上的皇后)</p>
<a id="more"></a>
<p>n皇后问题最常见的解决方法为dfs+回溯法，这里不过多阐述详细代码。我今天想要写的是一种利用位运算优化原本的方法，使得冲突的检测会更加简洁高效，从而更快的解决n皇后问题</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MAX=(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> <span class="comment">//row表示列，left表示左对角线，right表示右对角线，为1是不能放的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row!=MAX) <span class="comment">//如果不是所有列都有皇后 </span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=MAX&amp;~(row|ld|rd); <span class="comment">//pos表示可以放的位置</span></span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">0</span>) <span class="comment">//while循环枚举所有为1的位置，然后去放置皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=pos&amp;(-pos);<span class="comment">//lowbit操作，提取出最后一个1所在的位置</span></span><br><span class="line">            pos=pos^p; <span class="comment">//将p位置在pos中置为0</span></span><br><span class="line">            <span class="comment">//row|p把p二进制为1的位置放上皇后</span></span><br><span class="line">            <span class="comment">//(left|p)&lt;&lt;1更新left的下一行不能放的位置</span></span><br><span class="line">            <span class="comment">//(right|p)&gt;&gt;1更新right的下一行不能放的位置</span></span><br><span class="line">            f(row|p,(ld|p)&lt;&lt;<span class="number">1</span>,(rd|p)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//如果所有列都有皇后，则找到了一种可行的方法 </span></span><br><span class="line">		ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//因为没有放皇后，所以所有都是0 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>复合二次根式</title>
    <url>/2020/07/28/%E5%A4%8D%E5%90%88%E4%BA%8C%E6%AC%A1%E6%A0%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>化简二次根式</p>
<a id="more"></a>
<h2 id="1-二次根式的性质"><a href="#1-二次根式的性质" class="headerlink" title="1.二次根式的性质"></a>1.二次根式的性质</h2><p>二次根式的性质是根式化简的依据，而化二次根式为最简二次根式又是根式计算的基础，常用的基本性质有：</p>
<script type="math/tex; mode=display">(\sqrt{a})^2=a(a\geqslant 0),\sqrt{ab}=\sqrt{a}\cdot\sqrt{b}(a\geqslant 0,b\geqslant 0),\sqrt{\frac{a}{b}}=\frac{\sqrt{a}}{\sqrt{b}}(a\geqslant 0,b>0)</script><h2 id="2-复合二次根式定义"><a href="#2-复合二次根式定义" class="headerlink" title="2.复合二次根式定义"></a>2.复合二次根式定义</h2><p>复合二次根式(compound quadratic radical)是一种特殊根式 ，把二次根式中套叠着二次根式的情形叫做复合二次根式<br>1.通常把形如</p>
<script type="math/tex; mode=display">\sqrt{a\pm\sqrt{b}}</script><p>的根式叫做复合二次根式<br>2.把二次根式中套叠着二次根式的情形也叫做复合二次根式，如</p>
<script type="math/tex; mode=display">\sqrt{a+\sqrt{b+\sqrt{c}}}</script><h2 id="3-复合二次根式的相关定理及证明"><a href="#3-复合二次根式的相关定理及证明" class="headerlink" title="3.复合二次根式的相关定理及证明"></a>3.复合二次根式的相关定理及证明</h2><p><strong>定理</strong><br>设$\sqrt{a\pm\sqrt{b}}$是复合二次根式，则</p>
<script type="math/tex; mode=display">\boxed{\sqrt{a\pm\sqrt{b}}=\sqrt{\frac{a+\sqrt{a^2-b}}{2}}\pm\sqrt{\frac{a-\sqrt{a^2-b}}{2}}}</script><p><strong>证明：</strong><br>$\because\left(\sqrt{a+\sqrt{b}}+\sqrt{a-\sqrt{b}}\right)^2$</p>
<p>$=2a+2\sqrt{a^2-b}$</p>
<p>$\therefore\sqrt{a+\sqrt{b}}+\sqrt{a-\sqrt{b}}=\sqrt{2a+\sqrt{a^2-b}}=2\sqrt{\dfrac{a+\sqrt{a^2-b}}{2}}\ \ \ ①$</p>
<p>同理可得</p>
<p>$\therefore\sqrt{a+\sqrt{b}}-\sqrt{a-\sqrt{b}}=2\sqrt{\dfrac{a-\sqrt{a^2-b}}{2}}\ \ \ ②$</p>
<p>将① - ②可得</p>
<p>$\sqrt{a\pm\sqrt{b}}=\sqrt{\dfrac{a+\sqrt{a^2-b}}{2}}\pm \sqrt{\dfrac{a-\sqrt{a^2-b}}{2}}$</p>
<h2 id="4-复合二次根式的化简"><a href="#4-复合二次根式的化简" class="headerlink" title="4.复合二次根式的化简"></a>4.复合二次根式的化简</h2><h3 id="分母有理化"><a href="#分母有理化" class="headerlink" title="分母有理化"></a>分母有理化</h3><p>分母有理化就是把分母变成有理数（不带根号）<br>通常利用平方差公式$a^2-b^2=(a+b)(a-b)$来进行分母有理化<br>总之就是：分母上可以开方的开出来，不能开方的移到分母上去<br>例：分母有理化$\dfrac{1}{a+\sqrt{b}}(a,b都为有理数)$<br>可以发现，只需将分子分母同乘一个$a-\sqrt{b}$,分母便会变为平方差公式，进行化简<br>$原式=\dfrac{a-\sqrt{b}}{\left(a+\sqrt{b}\right)\cdot\left(a-\sqrt{b}\right)}$</p>
<p>$=\dfrac{a-\sqrt{b}}{a^2-b}$</p>
<h3 id="复合二次根式的化简"><a href="#复合二次根式的化简" class="headerlink" title="复合二次根式的化简"></a>复合二次根式的化简</h3><p>复合二次根式的化简是复合二次根式的一种恒等变形，将复合二次根式$\sqrt{a\pm\sqrt{b}}(a&gt;0,b&gt;0,a^2-b)$化简，就是通过代数式的恒等变形，将被开方数$(a\pm\sqrt{b})$凑成完全平方式，从而消去最外层的根号.如果凑不成完全平方式，则复合二次根式$\sqrt{a\pm\sqrt{b}}$就不能用两个有理数的平方根的和或差表示 ，即不能化简<br>复合二次根式化简的常用方法有：</p>
<h4 id="1-公式法"><a href="#1-公式法" class="headerlink" title="1.公式法"></a>1.公式法</h4><p>即利用公式</p>
<p>$\sqrt{a\pm\sqrt{b}}=\sqrt{\dfrac{a+\sqrt{a^2-b}}{2}}\pm \sqrt{\dfrac{a-\sqrt{a^2-b}}{2}}$</p>
<p>(a&gt;0，b&gt;0，$a^2-b$是完全平方式)，</p>
<h4 id="2-配方法-最常用"><a href="#2-配方法-最常用" class="headerlink" title="2.配方法(最常用)"></a>2.配方法(最常用)</h4><p>即先把$a\pm\sqrt{b}$配成一个代数式的完全平方，再从根号内开出来。</p>
<h4 id="3-方程组求解法"><a href="#3-方程组求解法" class="headerlink" title="3.方程组求解法"></a>3.方程组求解法</h4><p>假定</p>
<p>$a\pm\sqrt{b}=\left(\sqrt{x}\pm\sqrt{y}\right)^2$</p>
<p>解方程组</p>
<p>$\begin{cases}a=x+y\\b=2\sqrt{xy}\end{cases}$ </p>
<p><strong>解：</strong></p>
<p>$\begin{cases}a=x+y\ \ \ ①\\b=2\sqrt{xy}\ \ \ ②\end{cases}$</p>
<p>将②两边同时平方，得</p>
<p>$xy=\dfrac{b^2}{4}\ \ \ ③$ </p>
<p>由①可得</p>
<p>$x=a-y\ \ \ ④$</p>
<p>把④代入③得</p>
<p>$y^2-ay+\dfrac{b^2}{4}=0$</p>
<p>$\Delta=a^2-b^2$</p>
<p>若$\Delta&lt;0$则该复合二次根式无法化简</p>
<p>若$\Delta\geqslant 0$则该方程组的解为</p>
<p>$\begin{cases}x=\dfrac{a+\sqrt{a^2-b^2}}{2}\\\\y=\dfrac{a-\sqrt{a^2-b^2}}{2}\end{cases}$</p>
<h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h2><p><strong>例1</strong>（2005年全国初中数学联赛题）化简$\dfrac{1}{4+\sqrt{59+30\sqrt{2}}}+\dfrac{1}{3-\sqrt{66-40\sqrt{2}}}$的结果是（    ）</p>
<p>$\ \ \ \ A.无理数\ \ \ \ B.真分数\ \ \ \ C.奇数\ \ \ \ D.偶数$</p>
<p>[全解]<br>$\ \ \ \ \dfrac{1}{4+\sqrt{59+30\sqrt{2}}}+\dfrac{1}{3-\sqrt{66-40\sqrt{2}}}$</p>
<p>$=\dfrac{1}{4+\sqrt{50+30\sqrt{2}+9}}+\dfrac{1}{3-\sqrt{50-40\sqrt{2}+16}}$</p>
<p>$=\dfrac{1}{4+5\sqrt{2}+3}+\dfrac{1}{3-5\sqrt{2}+4}$</p>
<p>$=\dfrac{1}{7+5\sqrt{2}}+\dfrac{1}{7-5\sqrt{2}}$</p>
<p>$=\dfrac{7-5\sqrt{2}+7+5\sqrt{2}}{49-50}$</p>
<p>$=-14$</p>
<p>故选D.</p>
<p><strong>例2</strong>（2006年全国初中数学联赛题）已知a，b为有理数，且满足$a+b\sqrt{3}=\sqrt{6}\cdot\sqrt{1+\sqrt{4+2\sqrt{3}}}$，则$a+b$的值为（    ）</p>
<p>$\ \ \ \ A.2\ \ \ \ B.4\ \ \ \ C.6\ \ \ \ D.8$</p>
<p>[全解]<br>因为</p>
<p>$\ \ \ \ \sqrt{6}\cdot\sqrt{1+\sqrt{4+2\sqrt{3}}}$</p>
<p>$=\sqrt{6}\cdot\sqrt{1+(1+\sqrt{3})}$</p>
<p>$=\sqrt{6}\cdot\sqrt{\dfrac{4+2\sqrt{3}}{2}}$</p>
<p>$=\sqrt{6}\cdot\dfrac{1+\sqrt{3}}{\sqrt{2}}$</p>
<p>$=3+\sqrt{3}$</p>
<p>所以$a+b\sqrt{3}=3+\sqrt{3}$注意到a,b为有理数，且n不为完全平方数，$\sqrt{3}$为无理数，因此$a=3,b=1$，从而$a+b$的值为4</p>
<p>故选B.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>根式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何手动开平方</title>
    <url>/2020/07/28/%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E5%BC%80%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<p>较小的数开平方大家肯定都知道。但一遇到一个大数，那可就头晕了，那么一个大数该如何开平方呢，请往下阅读</p>
<a id="more"></a>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>首先划分数字成组，不管是整数还是小数，均以小数点为分界线，向左和向右每两位数字划为一个单元，直到不够两个数字为止</p>
<p>$1432542.2425342\rightarrow 1’43’25’42.24’25’34’2$</p>
<p>以7654.321为例，按照之前的划分可以看作76’54.32’1，首先计算76，9的平方是81，超过76了，不行；再看8的平方64，没有超76，差值等于12,从而找到最大且不超过第一个单元的数字<br>$\ \ \ \ \ \ \ 8$<br>$8\sqrt{76’54.32’1}$<br>$\ \ \ \ \ 64$<br>$\ \ \ \ \ \overline{12\ \ \ \ \ \ }$</p>
<p>关键的一步到了，和除法一样下移一个单元，移下来组成1254；而根结果现在只有一个8，取8<em>20=160，但160中的个位数字0先空着，计算16X</em>X刚不超过1254，这里算出是7，168<em>8超了，169</em>9更不行；算出差值为85。</p>
<p>$\ \ \ \ \ \ \ \ \ 8$<br>$\ \ 8\sqrt{76’54.32’1}$<br>$\ \ \ \ \ \ \ 64$<br>$168\ \overline{12\ 54\ \ \ \ \ \ }$<br>$\ \ \ \ \ \ \ 11\  69$<br>$\ \ \ \ \ \ \ \overline{\ \ \ 85\ \ \ \ \ \ }$</p>
<p>同理下移32，组成8532，这时的根结果为87，取87<em>20=1740，个位的0先空着，心算1745</em>5肯定会超，应该是1744*4=6976，计算出差值1556。</p>
<p>这时候只剩下1了，而下移两位是必须的，所以补0，即下移10组成155610；这时的根结果为874，取874<em>20=17480，个位先空着，计算出17488</em>8正合适，计算出差值15706。</p>
<p>如果还想计算下去，继续下移两个零，组成1570600，取8748<em>20=174960，这里估算还是8，即174968</em>8，以下具体步骤就省略了，这时的开方结果得到为87.488，或四舍五入为87.49。如果要求只保留一位小数，则结果就为87.5。当然若想求得更准确的位数，计算下去就可以了。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1016 旅行家的预算</title>
    <url>/2020/07/28/%E6%B4%9B%E8%B0%B7%20P1016%20%E6%97%85%E8%A1%8C%E5%AE%B6%E7%9A%84%E9%A2%84%E7%AE%97/</url>
    <content><![CDATA[<p>思路：反复贪心</p>
<a id="more"></a>
<h2 id="1-题面"><a href="#1-题面" class="headerlink" title="1.题面"></a>1.题面</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离D1、汽车油箱的容量C（以升为单位）、每升汽油能行驶的距离D2、出发点每升汽油价格P和沿途油站数N（N可以为零），油站ii离出发点的距离Di、每升汽油价格Pi（i=1,2,…,N）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，D1，C，D2，P，N。</p>
<p>接下来有N行。</p>
<p>第i+1行，两个数字，油站i离出发点的距离Di和每升汽油价格Pi。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>所需最小费用，计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出“No Solution”。</p>
<h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>275.6 11.9 27.4 2.8 2<br>102.0 2.9<br>220.0 2.2</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>26.95</p>
<h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>N≤6,其余数字≤500</p>
<h2 id="2-解题思路：反复贪心"><a href="#2-解题思路：反复贪心" class="headerlink" title="2.解题思路：反复贪心"></a>2.解题思路：反复贪心</h2><p><img src="https://img-blog.csdnimg.cn/20191229224412171.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI1NDY4Nw==,size_16,color_FFFFFF,t_70" alt=""><br>在图中红框范围内</p>
<ol>
<li>若有 p[0]&gt;p[j]，则找到第一个满足条件的 j，在A处只加注只可以到 j 处的油，再把 j 处看作为A重新进行如上操作，直到到终点为止</li>
<li>若无 p[0]&gt;p[j]，则找到其中最小的p[j]，在A处加满油，求出到 j 处油箱剩余的容积，再把 j 处看作为A重新进行如上操作，直到到终点为止</li>
<li>若无 j，则输出“No Solution”<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> d,p;</span><br><span class="line">&#125;a[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d1,c,d2,k,ans=<span class="number">0</span>,temp=<span class="number">0</span>; <span class="comment">//temp表示油箱还剩多少油 </span></span><br><span class="line">	<span class="keyword">int</span> n,i,flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;d1&gt;&gt;c&gt;&gt;d2&gt;&gt;a[<span class="number">0</span>].p&gt;&gt;n;</span><br><span class="line">	a[<span class="number">0</span>].d=<span class="number">0</span>;</span><br><span class="line">	a[n+<span class="number">1</span>].d=d1;</span><br><span class="line">	k=c*d2;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i].d&gt;&gt;a[i].p;	</span><br><span class="line">	&#125;</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(a[i].d&lt;d1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j=i+<span class="number">1</span>,minp=a[i+<span class="number">1</span>].p,minn=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[j].d-a[i].d&gt;k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"No Solution"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(a[j].d-a[i].d&lt;=k &amp;&amp; j&lt;=n+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j].p&lt;a[i].p)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(temp&gt;(a[j].d-a[i].d)/d2)</span><br><span class="line">					temp-=(a[j].d-a[i].d)/d2;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					ans+=((a[j].d-a[i].d)/d2-temp)*a[i].p;</span><br><span class="line">					temp=<span class="number">0</span>;	</span><br><span class="line">				&#125;</span><br><span class="line">				i=j;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a[j].p&gt;=a[i].p &amp;&amp; a[j].p&lt;minp)</span><br><span class="line">			&#123;</span><br><span class="line">				minp=a[j].p;</span><br><span class="line">				minn=j;	</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=(c-temp)*a[i].p;</span><br><span class="line">			temp=(k-a[minn].d+a[i].d)/d2;</span><br><span class="line">			i=minn;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;temp&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf"</span>,ans);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/07/28/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="一、关于图的几个概念"><a href="#一、关于图的几个概念" class="headerlink" title="一、关于图的几个概念"></a>一、关于图的几个概念</h2><h4 id="1-连通图："><a href="#1-连通图：" class="headerlink" title="1.连通图："></a>1.连通图：</h4><p>在<strong>无向图</strong>中，若任意两个顶点都有路径相通，则称该无向图为连通图。</p>
<h4 id="2-强连通图："><a href="#2-强连通图：" class="headerlink" title="2.强连通图："></a>2.强连通图：</h4><p>在<strong>有向图</strong>中，若任意两个顶点都有路径相通，则称该有向图为强连通图。</p>
<h4 id="3-权"><a href="#3-权" class="headerlink" title="3.权"></a>3.权</h4><p>在连通图中，若图的边具有一定的意义，每一条边都对应着一个价值，称为权</p>
<h4 id="4-连通网："><a href="#4-连通网：" class="headerlink" title="4.连通网："></a>4.连通网：</h4><p>权代表着连接连个顶点的代价，称这种连通图叫做连通网。</p>
<h4 id="5-生成树："><a href="#5-生成树：" class="headerlink" title="5.生成树："></a>5.生成树：</h4><p>一个连通图的生成树是指一个连通子图，它含有图中<strong>全部n个顶点</strong>，有且只有<strong>n-1条边</strong>（构成一个树）</p>
<h4 id="6-最小生成树："><a href="#6-最小生成树：" class="headerlink" title="6.最小生成树："></a>6.最小生成树：</h4><p>在一幅图的所有生成树中，<strong>所有边的权和最小</strong>的生成树，称为最小生成树。<br><img src="https://img-blog.csdnimg.cn/20200204102709380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI1NDY4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="二、Kruskal算法"><a href="#二、Kruskal算法" class="headerlink" title="二、Kruskal算法"></a>二、Kruskal算法</h2><h3 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1.算法原理"></a>1.算法原理</h3><p>此算法可以称为“加边法”，每一次选择一条代价最小的边，逐渐组成最小生成树<br>此算法的主要思路就是并查集和贪心<br>实现算法的步骤<br>（1）把图中的所有边按权值大小从小到大排序；<br>（2）按权值从小到大选择边（贪心思想），所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。<br>（3）重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</p>
<p><img src="https://img-blog.csdnimg.cn/20200205090111710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI1NDY4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><p>首先，我们来讲一个故事，听完这个故事，例题就学完了，算法就学精了<br>近年来，XX国城市道路建设和交通管理工作，在XX国家政府的支持下，取得了很大成绩。但是，随着XX国经济、社会的快速发展，道路交通的需求迅速增长，而道路交通供给却严重不足，XX国的一些城市交通拥堵严重，交通秩序较乱，交通事故不断上升。为改变上述状况，更好地适应XX国家经济、社会发展的要求，XX国政府决定在在XX国城市实施以提高道路交通管理水平为中心的“畅通工程”，大力解决道路交通的问题</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>Problem Description</strong><br>XX国某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。XX国省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br><strong>Input</strong><br>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。<br><strong>Output</strong><br>对每个测试用例，在1行里输出最小的公路总长度。<br><strong>Sample Input</strong><br>3<br>1 2 1<br>1 3 2<br>2 3 4<br>4<br>1 2 1<br>1 3 4<br>1 4 1<br>2 3 3<br>2 4 2<br>3 4 5<br>0<br><strong>Sample Output</strong><br>3<br>5</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">11000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,m;</span><br><span class="line">&#125;a[<span class="number">11000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.m&lt;b.m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]);</span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x);</span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">	&#123;</span><br><span class="line">		f[fx]=fy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,i,j,k,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			f[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].m;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+(n*(n<span class="number">-1</span>))/<span class="number">2</span>+<span class="number">1</span>,cmp);</span><br><span class="line">		j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(j&lt;=(n*(n<span class="number">-1</span>))/<span class="number">2</span> &amp;&amp; getf(a[j].a)==getf(a[j].b))</span><br><span class="line">				j++;</span><br><span class="line">			un(a[j].a,a[j].b);</span><br><span class="line">			ans+=a[j].m;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;a[j].a&lt;&lt;" "&lt;&lt;a[j].b&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p><strong>Problem Description</strong><br>XX国某省省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。<br><strong>Input</strong><br>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N<br>行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。<br><strong>Output</strong><br>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。<br><strong>Sample Input</strong><br>3 3<br>1 2 1<br>1 3 2<br>2 3 4<br>1 3<br>2 3 2<br>0 100<br><strong>Sample Output</strong><br>3<br>?</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">11000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,m;</span><br><span class="line">&#125;a[<span class="number">11000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.m&lt;b.m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]);</span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x);</span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">	&#123;</span><br><span class="line">		f[fx]=fy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,i,j,k,ans;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">			f[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].m;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">		j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(getf(a[j].a)==getf(a[j].b))</span><br><span class="line">			&#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;n)</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			un(a[j].a,a[j].b);</span><br><span class="line">			ans+=a[j].m;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;a[j].a&lt;&lt;" "&lt;&lt;a[j].b&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p><strong>Problem Description</strong><br>XX国有一个著名的景点“百岛湖”，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在XX国政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过XX国考察小组对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。<br><strong>Input</strong><br>输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。<br><strong>Output</strong><br>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.<br><strong>Sample Input</strong><br>2<br>2<br>10 10<br>20 20<br>3<br>1 1<br>2 2<br>1000 1000<br><strong>Sample Output</strong><br>1414.2<br>oh!</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">11000</span>],g[<span class="number">10010</span>][<span class="number">10010</span>],x[<span class="number">10010</span>],y[<span class="number">10010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">double</span> m;</span><br><span class="line">&#125;a[<span class="number">11000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.m&lt;b.m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]);</span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x);</span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">	&#123;</span><br><span class="line">		f[fx]=fy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c,i,j,k;</span><br><span class="line">	<span class="keyword">double</span> ans;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=c+<span class="number">1</span>;i++)</span><br><span class="line">			f[i]=i;</span><br><span class="line">		k=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=c;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">double</span> l=<span class="built_in">sqrt</span>(<span class="built_in">abs</span>(x[i]-x[j])*<span class="built_in">abs</span>(x[i]-x[j])+<span class="built_in">abs</span>(y[i]-y[j])*<span class="built_in">abs</span>(y[i]-y[j]));</span><br><span class="line">				<span class="keyword">if</span>(l&lt;<span class="number">10</span> || l&gt;<span class="number">1000</span>)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				a[k].a=i;</span><br><span class="line">				a[k].b=j;</span><br><span class="line">				a[k].m=l;</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		k--;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+k+<span class="number">1</span>,cmp);</span><br><span class="line">		j=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=c<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(j&lt;=k &amp;&amp; getf(a[j].a)==getf(a[j].b))</span><br><span class="line">			&#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;k)</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			un(a[j].a,a[j].b);</span><br><span class="line">			ans+=a[j].m*<span class="number">100.0</span>;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;a[j].a&lt;&lt;" "&lt;&lt;a[j].b&lt;&lt;endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"oh!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>,ans);</span><br><span class="line">		t--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p><strong>Problem Description</strong><br>XX星有许多城市，城市之间通过一种奇怪的高速公路SARS(Super Air Roam Structure—-超级空中漫游结构）进行交流，每条SARS都对行驶在上面的Flycar限制了固定的Speed，同时XX星人对 Flycar的“舒适度”有特殊要求，即乘坐过程中最高速度与最低速度的差越小乘坐越舒服 ,(理解为SARS的限速要求，flycar必须瞬间提速/降速，痛苦呀 ),<br>但XX星人对时间却没那么多要求。要你找出一条城市间的最舒适的路径。(SARS是双向的）。<br><strong>Input</strong><br>输入包括多个测试实例，每个实例包括：<br>第一行有2个正整数n (1&lt;n&lt;=200)和m (m&lt;=1000),表示有N个城市和M条SARS。<br>接下来的行是三个正整数StartCity,EndCity,speed,表示从表面上看StartCity到EndCity,限速为speedSARS。speed&lt;=1000000<br>然后是一个正整数Q（Q&lt;11),表示寻路的个数。<br>接下来Q行每行有2个正整数Start,End, 表示寻路的起终点。<br><strong>Output</strong><br>每个寻路要求打印一行，仅输出一个非负整数表示最佳路线的舒适度最高速与最低速的差。如果起点和终点不能到达，那么输出-1。<br><strong>Sample Input</strong><br>4 4<br>1 2 2<br>2 3 4<br>1 4 1<br>3 4 2<br>2<br>1 3<br>1 2<br><strong>Sample Output</strong><br>1<br>0</p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,m;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.m&lt;b.m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]);</span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x);</span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">	&#123;</span><br><span class="line">		f[fx]=fy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,q,i,j,k,s,e,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].m;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>,cmp);</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=q;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="number">1000010</span>;</span><br><span class="line">			<span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">					f[j]=j;</span><br><span class="line">				<span class="keyword">for</span>(j=i;j&lt;=m;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(getf(a[j].a)!=getf(a[j].b))</span><br><span class="line">						un(a[j].a,a[j].b);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(getf(s)==getf(e))</span><br><span class="line">					&#123;</span><br><span class="line">						ans=min(ans,a[j].m-a[i].m);</span><br><span class="line">						flag=<span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、Prim算法"><a href="#三、Prim算法" class="headerlink" title="三、Prim算法"></a>三、Prim算法</h2><h3 id="1-算法原理-1"><a href="#1-算法原理-1" class="headerlink" title="1.算法原理"></a>1.算法原理</h3><p>此算法可以称为“加点法”，每次选择对应的点其中权最小的边，加入到最小生成树中。因为最小生成树中的顶点包括所有在连通网中的顶点，所以算法可以从任意一个顶点开始，逐渐覆盖整个连通网的所有顶点。<br>初始有一个集合u代表了哪一个顶点在最小生成树中，选取任意一个顶点a，令u={a}<br>在集合u中的点和不在集合u中的点能够组成的边中，选择一条权最小的边，加入到最小生成树中，并把这条边所对应的点并入到集合u中。此时，由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组d,用来维护不在集合u中每个顶点与集合u中最小代价边信息<br>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。<br><img src="https://img-blog.csdnimg.cn/2020020509550321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI1NDY4Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-例题-1"><a href="#2-例题-1" class="headerlink" title="2.例题"></a>2.例题</h3><h4 id="例题1（此处用Prim算法）"><a href="#例题1（此处用Prim算法）" class="headerlink" title="例题1（此处用Prim算法）"></a>例题1（此处用Prim算法）</h4><h5 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h5><p><strong>Problem Description</strong><br>XX国有一个著名的景点“百岛湖”，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在XX国政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过XX国考察小组对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。<br><strong>Input</strong><br>输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。<br>每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。<br><strong>Output</strong><br>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.<br><strong>Sample Input</strong><br>2<br>2<br>10 10<br>20 20<br>3<br>1 1<br>2 2<br>1000 1000<br><strong>Sample Output</strong><br>1414.2<br>oh!</p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> in[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">double</span> dist[<span class="number">105</span>],x[<span class="number">105</span>],y[<span class="number">105</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> dx=x[a]-x[b];</span><br><span class="line">	<span class="keyword">double</span> dy=y[a]-y[b];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ed;</span><br><span class="line">	<span class="keyword">double</span> minn;</span><br><span class="line">	in[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i]=d(<span class="number">1</span>,i);</span><br><span class="line">		<span class="keyword">if</span>(dist[i]&lt;<span class="number">10</span>||dist[i]&gt;<span class="number">1000</span>)</span><br><span class="line">			dist[i]=<span class="number">1005</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		minn=<span class="number">1005</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(!in[j]&amp;&amp;dist[j]&lt;minn&amp;&amp;dist[j]&gt;=<span class="number">10</span>&amp;&amp;dist[j]&lt;=<span class="number">1000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				minn=dist[j];</span><br><span class="line">				ed=j;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(minn==<span class="number">1005</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		in[ed]=<span class="literal">true</span>;</span><br><span class="line">		ans+=minn*<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(d(ed,j)&gt;=<span class="number">10</span>)</span><br><span class="line">				dist[j]=min(dist[j],d(ed,j));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(in,<span class="literal">false</span>,<span class="keyword">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">		<span class="keyword">if</span>(prim())</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.1f"</span>,ans);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"oh!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><h5 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h5><p><img src="https://img-blog.csdnimg.cn/20200205094034394.gif" alt="在这里插入图片描述"></p>
<p><strong>Problem Description</strong></p>
<p>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.</p>
<p>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.</p>
<p>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.<br><strong>Sample Input</strong><br>9<br>A 2 B 12 I 25<br>B 3 C 10 H 40 I 8<br>C 2 D 18 G 55<br>D 1 E 44<br>E 2 F 60 G 38<br>F 0<br>G 1 H 35<br>H 1 I 35<br>3<br>A 2 B 10 C 40<br>B 1 C 20<br>0<br><strong>Sample Output</strong><br>216<br>30</p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">28</span>][<span class="number">28</span>],d[<span class="number">28</span>];</span><br><span class="line"><span class="keyword">bool</span> u[<span class="number">28</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,i,j;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">memset</span>(u,<span class="literal">false</span>,<span class="keyword">sizeof</span>(u));</span><br><span class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">char</span> c1,c2;</span><br><span class="line">			<span class="keyword">int</span> k,m;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;k;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;c2&gt;&gt;m;</span><br><span class="line">				g[c1-<span class="string">'A'</span>+<span class="number">1</span>][c2-<span class="string">'A'</span>+<span class="number">1</span>]=m;</span><br><span class="line">				g[c2-<span class="string">'A'</span>+<span class="number">1</span>][c1-<span class="string">'A'</span>+<span class="number">1</span>]=m;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		u[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[<span class="number">1</span>][i]!=<span class="number">0</span>)</span><br><span class="line">				d[i]=g[<span class="number">1</span>][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				d[i]=<span class="number">105</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> minn=<span class="number">105</span>,id=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(u[j]==<span class="number">0</span> &amp;&amp; d[j]&lt;minn)</span><br><span class="line">				&#123;</span><br><span class="line">					minn=d[j];</span><br><span class="line">					id=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=minn;</span><br><span class="line">			u[id]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(g[id][j]!=<span class="number">0</span>)</span><br><span class="line">					d[j]=min(d[j],g[id][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1541 乌龟棋</title>
    <url>/2020/07/28/%E6%B4%9B%E8%B0%B7%20P1541%20%E4%B9%8C%E9%BE%9F%E6%A3%8B/</url>
    <content><![CDATA[<p>思路：多维dp</p>
<a id="more"></a>
<p><a href="![img](file:///C:\Users\10705\AppData\Roaming\Tencent\QQTempSys\%W@GJ$ACOF(TYDYECOKVDYB.png">P1541 乌龟棋</a><a href="https://www.luogu.org/problem/P1541" target="_blank" rel="noopener">https://www.luogu.org/problem/P1541</a>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">400</span>],b,dp[<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,c[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">		c[b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c[<span class="number">1</span>];i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=c[<span class="number">2</span>];j++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=c[<span class="number">3</span>];k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=c[<span class="number">4</span>];x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">			dp[i][j][k][x]=max(dp[i<span class="number">-1</span>][j][k][x],dp[i][j][k][x]);</span><br><span class="line">		<span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">			dp[i][j][k][x]=max(dp[i][j<span class="number">-1</span>][k][x],dp[i][j][k][x]);</span><br><span class="line">		<span class="keyword">if</span>(k<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">			dp[i][j][k][x]=max(dp[i][j][k<span class="number">-1</span>][x],dp[i][j][k][x]);</span><br><span class="line">		<span class="keyword">if</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">			dp[i][j][k][x]=max(dp[i][j][k][x<span class="number">-1</span>],dp[i][j][k][x]);</span><br><span class="line">		dp[i][j][k][x]+=a[i+j*<span class="number">2</span>+k*<span class="number">3</span>+x*<span class="number">4</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[c[<span class="number">1</span>]][c[<span class="number">2</span>]][c[<span class="number">3</span>]][c[<span class="number">4</span>]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1548 棋盘问题</title>
    <url>/2020/07/28/%E6%B4%9B%E8%B0%B7%20P1548%20%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这题由于范围较小(1≤N≤100,1≤M≤100)</p>
<p>可以使用暴力AC</p>
<a id="more"></a>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,i,j,csquare=<span class="number">0</span>,crectangle=<span class="number">0</span>; <span class="comment">//csquare 统计正方形个数  crectangle 统计长方形个数 </span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">//输入 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//长  可以取任意在n以内的一个数   </span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++) <span class="comment">//宽  同上</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==j) <span class="comment">//如果长等于宽   代表是正方形 </span></span><br><span class="line">			csquare+=(n-i+<span class="number">1</span>)*(m-j+<span class="number">1</span>); </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			crectangle+=(n-i+<span class="number">1</span>)*(m-j+<span class="number">1</span>); <span class="comment">//由于第二遍会重复算长方形，所以不用担心需要乘以二 </span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		推导过程：</span></span><br><span class="line"><span class="comment">		总可能性=小长方形的长在大长方形的长中可能性 ×小长方形的宽在大长方形的宽中可能性 </span></span><br><span class="line"><span class="comment">		接下来只用求 长方形的长在大长方形的长中可能性 就可以啦</span></span><br><span class="line"><span class="comment">		我是这样推的： </span></span><br><span class="line"><span class="comment">			我们先把长方形看成长变成1的小长方形，这个小长方形每次都会往前推一格，直到尽头</span></span><br><span class="line"><span class="comment">			所以，我们只用看它推了多少格就行了</span></span><br><span class="line"><span class="comment">			假设推了n格</span></span><br><span class="line"><span class="comment">			n=大长方形长-小长方形长+1</span></span><br><span class="line"><span class="comment">		然后就没有了...</span></span><br><span class="line"><span class="comment">		*/</span> </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;csquare&lt;&lt;<span class="string">" "</span>&lt;&lt;crectangle&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//完美结束 q(≧▽≦q) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1803 【凌乱的yyy线段覆盖】</title>
    <url>/2020/07/28/%E6%B4%9B%E8%B0%B7%20P1803%20%E3%80%90%E5%87%8C%E4%B9%B1%E7%9A%84yyy%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96%E3%80%91/</url>
    <content><![CDATA[<p>这道题是一道贪心的题<br>如果我们要看贪心策略是否正确，我们必须先要举不出反例或者证明这是绝对正确</p>
<a id="more"></a>
<h4 id="几种常见错误的贪心策略："><a href="#几种常见错误的贪心策略：" class="headerlink" title="几种常见错误的贪心策略："></a>几种常见错误的贪心策略：</h4><h4 id="1-最早开始"><a href="#1-最早开始" class="headerlink" title="1.最早开始"></a>1.最早开始</h4><p>按照越早开始的排序，这个十分容易举出反例</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/68638.png" alt=""></p>
<p>假如这种规则是对的，那么就会选择蓝色的线段，但最多的形况不是这样，所以是错误的</p>
<h4 id="2-最短线段"><a href="#2-最短线段" class="headerlink" title="2.最短线段"></a>2.最短线段</h4><p>按照线段长度的排序，这个也十分容易举出反例</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/68636.png" alt=""></p>
<p>假如这种规则是对的，那么就会选择蓝色的线段，但最多的形况不是这样，所以是错误的</p>
<h4 id="3-冲突最少"><a href="#3-冲突最少" class="headerlink" title="3.冲突最少"></a>3.冲突最少</h4><p>按照线段冲突的个数的排序，这个挺难举出反例（也挺难想到的）</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/68643.png" alt=""></p>
<p>假如这种规则是对的，那么就会选择中间蓝色的线段，但最多的形况是选红色的线段，所以这个也是错误的</p>
<p>接下来讲一下正确的写法：最早结束</p>
<p>证明:排序后当你选了一个线段后,下一个开始位置一定大于等于现在线段的终止位置，所以终止位置肯定越早越好</p>
<p>这个是举不出反例的，主要就是按结束顺序排序再输出</p>
<p>AC代码如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> //定义结构体 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> start,end; <span class="comment">//开始和结束 </span></span><br><span class="line">&#125;a[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> <span class="comment">//快排规则定义 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.end&lt;b.end; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i].start&gt;&gt;a[i].end; </span><br><span class="line">	sort(a,a+n,cmp); <span class="comment">//系统自带的快排 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i].start==<span class="number">-1</span>)	<span class="keyword">continue</span>; <span class="comment">//这里我直接用start判断是否可以执行 </span></span><br><span class="line">		ans++; <span class="comment">//方案数++ </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">			<span class="keyword">if</span>(a[j].start&lt;a[i].end)</span><br><span class="line">				a[j].start=<span class="number">-1</span>; <span class="comment">//把与a[i]重合的设置成-1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1115 最大子段和</title>
    <url>/2020/07/28/%E6%B4%9B%E8%B0%B7%20P1115%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<p>思路：分治</p>
<p>实现方法：递归</p>
<a id="more"></a>
<h2 id="一、如何实现"><a href="#一、如何实现" class="headerlink" title="一、如何实现"></a>一、如何实现</h2><h3 id="1-每次从中间切一刀"><a href="#1-每次从中间切一刀" class="headerlink" title="1.每次从中间切一刀"></a>1.每次从中间切一刀</h3><h3 id="2-找出左边的最大子段"><a href="#2-找出左边的最大子段" class="headerlink" title="2.找出左边的最大子段"></a>2.找出左边的最大子段</h3><p>如图</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/66227.png" alt=""></p>
<p>递归蓝色区域</p>
<h3 id="3-找出右边的最大子段（与找出左边的最大子段相似）"><a href="#3-找出右边的最大子段（与找出左边的最大子段相似）" class="headerlink" title="3.找出右边的最大子段（与找出左边的最大子段相似）"></a>3.找出右边的最大子段（与找出左边的最大子段相似）</h3><p>如图</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/66228.png" alt=""></p>
<p>递归蓝色区域</p>
<h3 id="4-找出中间的最大子段"><a href="#4-找出中间的最大子段" class="headerlink" title="4.找出中间的最大子段"></a>4.找出中间的最大子段</h3><p>所谓中间就是图中蓝色区域</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/66231.png" alt=""></p>
<h3 id="重点实现"><a href="#重点实现" class="headerlink" title="重点实现"></a>重点实现</h3><h4 id="1）如何实现"><a href="#1）如何实现" class="headerlink" title="1）如何实现"></a>1）如何实现</h4><p><img src="https://cdn.luogu.com.cn/upload/pic/66254.png" alt=""></p>
<p>如图所示,蓝色区域等于红色区域加上绿色区域</p>
<p>所以就可以先算出红色区域的最大子段在算出绿色区域的最大子段最后相加就行了</p>
<h4 id="2）代码实现"><a href="#2）代码实现" class="headerlink" title="2）代码实现"></a>2）代码实现</h4><p>主要代码<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">long long i,<span class="attribute">left_sum</span>=0,l_max=a[mid],<span class="attribute">right_sum</span>=0,r_max=a[mid+1];</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=mid;i&gt;=left;i--) </span><br><span class="line">&#123;</span><br><span class="line">	left_sum+=a[i];</span><br><span class="line">	<span class="keyword">if</span>(left_sum&gt;l_max)</span><br><span class="line">		<span class="attribute">l_max</span>=left_sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=mid+1;i&lt;=right;i++)</span><br><span class="line">&#123;</span><br><span class="line">	right_sum+=a[i];</span><br><span class="line">	<span class="keyword">if</span>(right_sum&gt;r_max)</span><br><span class="line">		<span class="attribute">r_max</span>=right_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、注意事项"><a href="#二、注意事项" class="headerlink" title="二、注意事项"></a>二、注意事项</h2><h2 id="以下都是本人认为容易出错的地方"><a href="#以下都是本人认为容易出错的地方" class="headerlink" title="以下都是本人认为容易出错的地方"></a>以下都是本人认为容易出错的地方</h2><h3 id="1-long-long-的使用地方"><a href="#1-long-long-的使用地方" class="headerlink" title="1.long long 的使用地方"></a>1.long long 的使用地方</h3><p>在完整代码中,我命名变量通常都是long long类型的,这主要是因为不使用会爆掉,我们可以简单估一下：</p>
<p>int范围：-2147483648 ~ +2147483647</p>
<p>long long范围：-9223372036854775808 ~+9223372036854775807 </p>
<p>题目中N≤200000,假设每个数10000多的话,数组累加起来就会爆掉int类型,所以还是用long long妥当</p>
<h3 id="2-数组切记要开大"><a href="#2-数组切记要开大" class="headerlink" title="2.数组切记要开大"></a>2.数组切记要开大</h3><p>重要的事情说三遍：数组要开大！数组要开大！数组要开大！</p>
<p>只要是数组有超过10000个元素的话，一般都要开在外面，而且一定要开大一点，否则就会爆掉。此题给的是N≤200000，所以我们就应该开200005的数组</p>
<h2 id="三、实现代码"><a href="#三、实现代码" class="headerlink" title="三、实现代码"></a>三、实现代码</h2><p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;//万能头不解释 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200005</span>];<span class="comment">//开个足够大的数组 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max3</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c)</span> <span class="comment">//这个函数可有可无,只是为了方(mei)便(guan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> max(a,max(b,c)); <span class="comment">//判断三个数中的最大的数 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//-------------------以下为主要代码 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> left,<span class="keyword">long</span> <span class="keyword">long</span> right)</span> <span class="comment">//一直返回最大值 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> mid=(left+right)/<span class="number">2</span>; <span class="comment">//运用了分治的思想 </span></span><br><span class="line">	<span class="keyword">if</span>(left==right) <span class="comment">//终止条件 </span></span><br><span class="line">		<span class="keyword">return</span> a[left]; <span class="comment">// 切到只剩一个数时 返回a[left]或a[right]随意(自己是最大值) </span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> left_max; <span class="comment">//-----------------左最大值 </span></span><br><span class="line">	left_max=f(left,mid); <span class="comment">//递归 </span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> right_max; <span class="comment">//-----------------右最大值 </span></span><br><span class="line">	right_max=f(mid+<span class="number">1</span>,right); <span class="comment">//递归(注意是mid+1) </span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> i,left_sum=<span class="number">0</span>,l_max=a[mid],right_sum=<span class="number">0</span>,r_max=a[mid+<span class="number">1</span>]; <span class="comment">//-----------------中最大值 </span></span><br><span class="line">	<span class="keyword">for</span>(i=mid;i&gt;=left;i--) <span class="comment">//求左边最大值(注意和之前不同了,这是从中间向两边找最大值) </span></span><br><span class="line">	&#123;</span><br><span class="line">		left_sum+=a[i]; <span class="comment">//逐个累加 </span></span><br><span class="line">		<span class="keyword">if</span>(left_sum&gt;l_max) <span class="comment">//如果sum&gt;max就让max=sum </span></span><br><span class="line">			l_max=left_sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=mid+<span class="number">1</span>;i&lt;=right;i++) <span class="comment">//求右边最大值</span></span><br><span class="line">	&#123;</span><br><span class="line">		right_sum+=a[i]; <span class="comment">//同上 </span></span><br><span class="line">		<span class="keyword">if</span>(right_sum&gt;r_max)</span><br><span class="line">			r_max=right_sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> MAX=max3(left_max,right_max,l_max+r_max); <span class="comment">//因为最大值要么在左边,要么在右边,要么在中间,所以去三者最大值然后返回就行了  </span></span><br><span class="line">	<span class="keyword">return</span> MAX; <span class="comment">//返回最大值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//主函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,i;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//输入 </span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f(<span class="number">1</span>,n)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输入数据然后输出 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式初步</title>
    <url>/2020/07/28/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="二元线性方程组与二阶行列式"><a href="#二元线性方程组与二阶行列式" class="headerlink" title="二元线性方程组与二阶行列式"></a>二元线性方程组与二阶行列式</h2><p>用消元法解二元线性方程组</p>
<p>$\begin{cases}a_{11}x_1+a_{12}x_1=b_1\\a_{21}x_2+a_{22}x_2=b_2\end{cases}$ </p>
<p>为消去未知数$x_2$，可以把$a_{22}$与$a_{12}$分别乘上列两方程，然后两个方程相减，得</p>
<p> $(a_{11}a_{22}-a_{12}a_{21})x_1=b_1a_{22}-a_{12}b_2$</p>
<p>同理，消去𝑥1，可得：</p>
<p> $(a_{11}a_{22}-a_{12}a_{21})x_2=b_2a_{11}-a_{21}b_1$</p>
<p>可以得出</p>
<p>$x_1=\dfrac{b_1a_{22}-a_{12}b_2}{(a_{11}a_{22}-a_{12}a_{21})x_1},x_2=\dfrac{b_2a_{11}-a_{21}b_1}{(a_{11}a_{22}-a_{12}a_{21})x_1}$</p>
<p>通过解可以总结出一些规律</p>
<p>我们可以把方程的系数$a_{11}\quad a_{12}\\a_{21}\quad a_{22}$共二行二列（横排称为行、竖排称为列）排成一个数表的形式，表达式$a_{11}a_{22}-a_{12}a{21}$叫做这个数表对</p>
<p>应的行列式，记做： $\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}$ </p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title>题解hdu1232</title>
    <url>/2020/07/26/%E9%A2%98%E8%A7%A3hdu1232/</url>
    <content><![CDATA[<h3 id="hdu1232-畅通工程"><a href="#hdu1232-畅通工程" class="headerlink" title="hdu1232 畅通工程"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">hdu1232 畅通工程</a></h3><a id="more"></a>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><h5 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h5><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p>
<h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><p>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p>
<h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><p>1<br>0<br>2<br>998</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>由于题目本身给的输入样例太水了并且是多组数据输入，不好分析，所以我们先自己编一个样例，下面是我自己编的一个样例：<br>输入<br>10 7<br>1 2<br>2 4<br>2 3<br>7 8<br>5 8<br>2 9<br>6 10<br>输出<br>2<br>依照这个样例我们可以画出如下图所示的一幅图，其中每个城市用一个编号来表示，每条边表示这两个城市之间有一条路径<br><img src="https://img-blog.csdnimg.cn/20200119235803180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI1NDY4Nw==,size_16,color_FFFFFF,t_70" alt="图2-1-2-1"><br>接下来我们来分析一下这个图，从这个图中我们可以看到有三个城市堆，分别是1、2、3、4、9城市一堆，5、7、8城市一堆和6、10城市一堆，这三个堆互不相连，所以这道题中要求的最少增加的路径数肯定等于把这三堆连起来所用的最少增加的路径数，同时也等于城市堆数减一<br>所以，问题转化为了求城市堆的个数，但是如何确定城市的堆数呢，我们可以在城市内部建立联系，我们可以让每个城市都有一个属于他自己的一个祖先，合并的时候把他们的祖先合并，然后看看有几个城市没有祖先了或者说他自己就是他自己的祖先，那么这些城市堆数加1</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="1-总体代码"><a href="#1-总体代码" class="headerlink" title="1.总体代码"></a>1.总体代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,p,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]);</span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x);</span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">		f[fy]=fx;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			f[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q;</span><br><span class="line">			un(p,q);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">				ans++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-分步讲解"><a href="#2-分步讲解" class="headerlink" title="2.分步讲解"></a>2.分步讲解</h5><h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>]; <span class="comment">//储存第i个城市的祖先是f[i]</span></span><br><span class="line"><span class="keyword">int</span> n,m,i,j,p,q;</span><br></pre></td></tr></table></figure>
<h6 id="主体代码"><a href="#主体代码" class="headerlink" title="主体代码"></a>主体代码</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			f[i]=i; <span class="comment">//初始化每个城市的祖先都是自己</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q;</span><br><span class="line">			un(p,q); <span class="comment">//合并两个城市p，q</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">				ans++; <span class="comment">//如果这个城市的祖先是他自己，那么城市堆数加1</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查集"><a href="#查集" class="headerlink" title="查集"></a>查集</h6><p>找祖先的过程<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i) <span class="comment">//如果他自己就是他的祖先，那么返回他</span></span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> getf(f[i]); <span class="comment">//如果不是，继续一层层往下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是我们还会发现，每一次都从头往后找，有点太麻烦了，于是我们可以每次存储下来他们最终的祖先，这就叫做路径压缩<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i) </span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]); <span class="comment">//路径压缩</span></span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x); <span class="comment">//找祖先</span></span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">		f[fy]=fx; <span class="comment">//把他们祖先合并</span></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>

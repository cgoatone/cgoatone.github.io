<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bitset</title>
    <url>/2020/07/27/bitset/</url>
    <content><![CDATA[<p>bitset是c++中的一个stl</p>
<a id="more"></a>

<p>如果需要使用bitset，则需要在头文件中定义#include<bitset></p>
<p>它是一种存储二进制字符串的结构，每一位只能为0或1，每一位只占用1bit</p>
<p>我们通常可以这样构造</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;长度&gt; 名称;</span><br><span class="line"><span class="built_in">bitset</span>&lt;12&gt; a;</span><br></pre></td></tr></table></figure>

<p>我们可以像操纵数组一样操纵bitset</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;12&gt; a;</span><br><span class="line"></span><br><span class="line">a[i]=<span class="number">1</span> <span class="comment">//给bitset的第i为赋值为1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i]; <span class="comment">//输入一个01字符串到bitset里</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出bitset的第i位</span></span><br></pre></td></tr></table></figure>

<p>bitset自带有一些常用的二进制操纵符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;12&gt; a,b;</span><br><span class="line"></span><br><span class="line">a^b <span class="comment">//异或 相同为0不同为1</span></span><br><span class="line">a&amp;b <span class="comment">//按位与 同1为1其余为0</span></span><br><span class="line">a|b <span class="comment">//按位或 有1为1其余为0</span></span><br><span class="line">a&lt;&lt;=<span class="number">2</span> <span class="comment">//左移2位并赋值</span></span><br><span class="line">a&gt;&gt;=<span class="number">2</span> <span class="comment">//右移2位并赋值</span></span><br><span class="line">a&lt;&lt;<span class="number">2</span> <span class="comment">//左移2位</span></span><br><span class="line">a&gt;&gt;<span class="number">2</span> <span class="comment">//右移2位</span></span><br><span class="line">~a <span class="comment">//按位取反</span></span><br><span class="line">a==b <span class="comment">//判断是否相等</span></span><br><span class="line">a!=b <span class="comment">//判断是否不相等</span></span><br></pre></td></tr></table></figure>

<p>二进制还有一些经典的操作</p>
<p>a为一个二进制字符串</p>
<p>1.lowbit操作(找到最后一个1所在的位置)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=a&amp;(-a) <span class="comment">//a就为最后一个1所在的位置</span></span><br></pre></td></tr></table></figure>

<p>2.清零最低位的1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=a&amp;(a<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>3.一个数异或偶数次还是原来的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a=^(^a)</span><br></pre></td></tr></table></figure>

<p>4.判断奇偶</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x&amp;<span class="number">1</span>==<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>5.判断第i位是否为1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(a&gt;&gt;(i<span class="number">-1</span>))&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>noip提高组专题复习1-枚举</title>
    <url>/2020/07/26/noip%E6%8F%90%E9%AB%98%E7%BB%84%E4%B8%93%E9%A2%98%E5%A4%8D%E4%B9%A01-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h2 id="Flip-Game-poj-1753"><a href="#Flip-Game-poj-1753" class="headerlink" title="Flip Game poj-1753"></a>Flip Game <a href="http://poj.org/problem?id=1753" target="_blank" rel="noopener">poj-1753</a></h2><p>题意：给你一个4*4的黑白棋盘,每次可以将一个棋子反转颜色,同时这个棋子的上下左右都会反转,问你最少反转几次,可以将整个棋盘变成同色的无解输出Impossible<br>题解：可以通过dfs暴力枚举得出答案；可以状态压缩，用二进制枚举，枚举出怎么翻的所有情况，求出答案</p>
<p>dfs代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路： </span></span><br><span class="line"><span class="comment">暴力dfs</span></span><br><span class="line"><span class="comment">每个格子最多翻一次 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> tx[<span class="number">7</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,ty[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,ans=<span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">//翻第x行y列的棋子以及上下左右的棋子 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> newx=x+tx[i],newy=y+ty[i];</span><br><span class="line">		<span class="keyword">if</span>(newx&gt;=<span class="number">0</span> &amp;&amp; newx&lt;<span class="number">4</span> &amp;&amp; newy&gt;=<span class="number">0</span> &amp;&amp; newy&lt;<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[newx][newy]==<span class="string">'b'</span>)</span><br><span class="line">				g[newx][newy]=<span class="string">'w'</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g[newx][newy]=<span class="string">'b'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> <span class="comment">//检查是否全部同色</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">char</span> f=g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[i][j]!=f)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> t)</span> <span class="comment">//dfs枚举 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">16</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">			ans=min(ans,step);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x=t/<span class="number">4</span>,y=t%<span class="number">4</span>;</span><br><span class="line">	change(x,y);</span><br><span class="line">	dfs(step+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">	change(x,y);</span><br><span class="line">	dfs(step,t+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;g[i];</span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">200</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二进制枚举代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路： </span></span><br><span class="line"><span class="comment">用二进制位运算来状态压缩</span></span><br><span class="line"><span class="comment">1表示翻，0表示不翻，所以翻不翻的所有情况都可以通过二进制枚举出来 </span></span><br><span class="line"><span class="comment">0000=0</span></span><br><span class="line"><span class="comment">0001=1</span></span><br><span class="line"><span class="comment">0010=2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">1111=15</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">与运算 &amp;</span></span><br><span class="line"><span class="comment">同为一才为一 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> tx[<span class="number">7</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,ty[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,ans=<span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j)</span> <span class="comment">//翻第j/4行j%4列的棋子以及上下左右的棋子 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,x=j/<span class="number">4</span>,y=j%<span class="number">4</span>; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> newx=x+tx[i],newy=y+ty[i];</span><br><span class="line">		<span class="keyword">if</span>(newx&gt;=<span class="number">0</span> &amp;&amp; newx&lt;<span class="number">4</span> &amp;&amp; newy&gt;=<span class="number">0</span> &amp;&amp; newy&lt;<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[newx][newy]==<span class="string">'b'</span>)</span><br><span class="line">				g[newx][newy]=<span class="string">'w'</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				g[newx][newy]=<span class="string">'b'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> <span class="comment">//检查是否全部同色 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">char</span> f=g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[i][j]!=f)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;g[i];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="number">1</span> &lt;&lt; <span class="number">16</span>);i++) <span class="comment">//枚举所有翻的情况 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> step=<span class="number">0</span>; <span class="comment">//走了几步 </span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="comment">//判断第j位为是否为1</span></span><br><span class="line">			&#123;</span><br><span class="line">				change(j);</span><br><span class="line">				step++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(check())</span><br><span class="line">			ans=min(ans,step);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="comment">//判断第j位为是否为1</span></span><br><span class="line">				change(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans==<span class="number">200</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subsequence-UVA-1121"><a href="#Subsequence-UVA-1121" class="headerlink" title="Subsequence UVA-1121"></a>Subsequence <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3562" target="_blank" rel="noopener">UVA-1121</a></h2><p>题意：给你n和S以及n个数,求最短的连续子序列的长度使得这个连续子序列的和大于等于S，无解输出0<br>题解：预处理前缀和sum[i]=前i个数的和，二分枚举最小符合条件的右端点，找出最小的答案，否则输出0</p>
<p>二分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">二分，预处理前缀和sum[i]=前i个数的和，二分枚举最小符合条件的右端点 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,s,a,sum[<span class="number">100050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">100010</span>;</span><br><span class="line">		sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">			sum[i]=sum[i<span class="number">-1</span>]+a; <span class="comment">//前缀和 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> l=i,r=n,best=<span class="number">0</span>; <span class="comment">//二分右端点 </span></span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(sum[mid]-sum[i<span class="number">-1</span>]&gt;=s)</span><br><span class="line">				&#123;</span><br><span class="line">					best=mid;</span><br><span class="line">					r=mid<span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(best!=<span class="number">0</span>)</span><br><span class="line">				ans=min(ans,best-i+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">100010</span>)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/syntaxhighlight&gt;</span><br><span class="line">尺取法代码：</span><br><span class="line">&lt;syntaxhighlight lang=<span class="string">"C++"</span> line&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">尺取法，可以发现第i+1个数最小符合条件的右端点一定大于第i个数最小符合条件的右端点，</span></span><br><span class="line"><span class="comment">所以可以存储上一个数最小符合条件的右端点，从这个点开始枚举，复杂度O(n) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> n,s,a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">100010</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>,sum=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(j+<span class="number">1</span>&lt;=n &amp;&amp; sum&lt;s)</span><br><span class="line">			&#123;</span><br><span class="line">				sum+=a[j+<span class="number">1</span>];</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;=s)</span><br><span class="line">				ans=min(ans,j-i+<span class="number">1</span>);</span><br><span class="line">			sum-=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">100010</span>)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Xor-Sum-2-AtCoder-arc098-b"><a href="#Xor-Sum-2-AtCoder-arc098-b" class="headerlink" title="Xor Sum 2 AtCoder - arc098_b"></a>Xor Sum 2 <a href="https://vjudge.net/problem/AtCoder-arc098_b/origin" target="_blank" rel="noopener">AtCoder - arc098_b</a></h2><p>题意：求有多少区间的xor之和等于区间的数的和<br>题解：尺取法，可以发现第i+1个数最小符合条件的右端点一定大于第i个数最小符合条件的右端点，<br>所以可以存储上一个数最小符合条件的右端点，从这个点开始枚举<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">尺取法，可以发现第i+1个数最小符合条件的右端点一定大于第i个数最小符合条件的右端点，</span></span><br><span class="line"><span class="comment">所以可以存储上一个数最小符合条件的右端点，从这个点开始枚举 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">300100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n,i;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">0</span>,suma=<span class="number">0</span>,sumb=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j+<span class="number">1</span>&lt;=n &amp;&amp; (suma^a[j+<span class="number">1</span>])==sumb+a[j+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			suma^=a[j+<span class="number">1</span>];</span><br><span class="line">			sumb+=a[j+<span class="number">1</span>];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=j-i+<span class="number">1</span>; </span><br><span class="line">		suma^=a[i];</span><br><span class="line">		sumb-=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Maximum-Subsequence-CodeForces-888E"><a href="#Maximum-Subsequence-CodeForces-888E" class="headerlink" title="Maximum Subsequence CodeForces - 888E"></a>Maximum Subsequence <a href="https://vjudge.net/problem/CodeForces-888E/origin" target="_blank" rel="noopener">CodeForces - 888E</a></h2><p>题意：给你最多35个整数, 选出一个子集使得这个子集的和取余m最大,求最大的余数<br>题解：折半枚举，把数组分成两半，分成两半后，暴力枚举前一半的组合，保存在b[]，<br>进行排序，复杂度最多为2^18，枚举完后，再暴力枚举另一半的所有组合，在<br>前一半的组合里寻找一个数，使这个数与一个组合加起来模m最大（在b数组中<br>查找小于等于m-1-x的最大的数，如果不存在取最大的数）<br>问题变成了在有序数组中查找一个数，二分解决<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">折半枚举，把数组分成两半，分成两半后，暴力枚举前一半的组合，保存在b[]，</span></span><br><span class="line"><span class="comment">进行排序，复杂度最多为2^18，枚举完后，再暴力枚举另一半的所有组合，在</span></span><br><span class="line"><span class="comment">前一半的组合里寻找一个数，使这个数与一个组合加起来模m最大（在b数组中</span></span><br><span class="line"><span class="comment">查找小于等于m-1-x的最大的数，如果不存在取最大的数）</span></span><br><span class="line"><span class="comment">问题变成了在有序数组中查找一个数，二分解决 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">40</span>],b[<span class="number">262200</span>],temp=<span class="number">0</span>,n,m,i,j,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=temp<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(b[mid]&gt;x)</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i]%=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n/<span class="number">2</span>));i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">			&#123;</span><br><span class="line">				sum=(sum+a[j])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		b[temp++]=sum;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(b,b+temp);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-(n/<span class="number">2</span>)));i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;(n-(n/<span class="number">2</span>));j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">			&#123;</span><br><span class="line">				sum=(sum+a[j+(n/<span class="number">2</span>)])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> x=find(m-sum<span class="number">-1</span>);</span><br><span class="line">		ans=max(ans,(b[x]+sum)%m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>noip提高组</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/2020/07/25/hello-world/</url>
    <content><![CDATA[<p>这是我的第一篇blog</p>
<a id="more"></a>

<p>我的微信公众号是超级初中生，欢迎大家扫码关注</p>
<p><img src="https://i.loli.net/2020/07/26/oFH45KU1E3L2Qfd.jpg" alt="微信公众号"></p>
<p>我的头条号的名字也是超级初中生，欢迎大家关注</p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式初步</title>
    <url>/2020/07/28/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>信息学</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title>题解hdu1232</title>
    <url>/2020/07/26/%E9%A2%98%E8%A7%A3hdu1232/</url>
    <content><![CDATA[<h3 id="hdu1232-畅通工程"><a href="#hdu1232-畅通工程" class="headerlink" title="hdu1232 畅通工程"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">hdu1232 畅通工程</a></h3><a id="more"></a>

<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><h5 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h5><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p>
<h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><p>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p>
<h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><p>1<br>0<br>2<br>998</p>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>由于题目本身给的输入样例太水了并且是多组数据输入，不好分析，所以我们先自己编一个样例，下面是我自己编的一个样例：<br>输入<br>10 7<br>1 2<br>2 4<br>2 3<br>7 8<br>5 8<br>2 9<br>6 10<br>输出<br>2<br>依照这个样例我们可以画出如下图所示的一幅图，其中每个城市用一个编号来表示，每条边表示这两个城市之间有一条路径<br><img src="https://img-blog.csdnimg.cn/20200119235803180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI1NDY4Nw==,size_16,color_FFFFFF,t_70" alt="图2-1-2-1"><br>接下来我们来分析一下这个图，从这个图中我们可以看到有三个城市堆，分别是1、2、3、4、9城市一堆，5、7、8城市一堆和6、10城市一堆，这三个堆互不相连，所以这道题中要求的最少增加的路径数肯定等于把这三堆连起来所用的最少增加的路径数，同时也等于城市堆数减一<br>所以，问题转化为了求城市堆的个数，但是如何确定城市的堆数呢，我们可以在城市内部建立联系，我们可以让每个城市都有一个属于他自己的一个祖先，合并的时候把他们的祖先合并，然后看看有几个城市没有祖先了或者说他自己就是他自己的祖先，那么这些城市堆数加1</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="1-总体代码"><a href="#1-总体代码" class="headerlink" title="1.总体代码"></a>1.总体代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,p,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]);</span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x);</span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">		f[fy]=fx;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			f[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q;</span><br><span class="line">			un(p,q);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">				ans++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-分步讲解"><a href="#2-分步讲解" class="headerlink" title="2.分步讲解"></a>2.分步讲解</h5><h6 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>]; <span class="comment">//储存第i个城市的祖先是f[i]</span></span><br><span class="line"><span class="keyword">int</span> n,m,i,j,p,q;</span><br></pre></td></tr></table></figure>

<h6 id="主体代码"><a href="#主体代码" class="headerlink" title="主体代码"></a>主体代码</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			f[i]=i; <span class="comment">//初始化每个城市的祖先都是自己</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q;</span><br><span class="line">			un(p,q); <span class="comment">//合并两个城市p，q</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(f[i]==i)</span><br><span class="line">				ans++; <span class="comment">//如果这个城市的祖先是他自己，那么城市堆数加1</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查集"><a href="#查集" class="headerlink" title="查集"></a>查集</h6><p>找祖先的过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i) <span class="comment">//如果他自己就是他的祖先，那么返回他</span></span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">return</span> getf(f[i]); <span class="comment">//如果不是，继续一层层往下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们还会发现，每一次都从头往后找，有点太麻烦了，于是我们可以每次存储下来他们最终的祖先，这就叫做路径压缩</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[i]==i) </span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	f[i]=getf(f[i]); <span class="comment">//路径压缩</span></span><br><span class="line">	<span class="keyword">return</span> f[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy;</span><br><span class="line">	fx=getf(x); <span class="comment">//找祖先</span></span><br><span class="line">	fy=getf(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">		f[fy]=fx; <span class="comment">//把他们祖先合并</span></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>使用位运算解决n皇后问题</title>
    <url>/2020/07/26/%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A7%A3%E5%86%B3n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(皇后可以攻击在同一条斜线或直线上的皇后)</p>
<a id="more"></a>

<p>n皇后问题最常见的解决方法为dfs+回溯法，这里不过多阐述详细代码。我今天想要写的是一种利用位运算优化原本的方法，使得冲突的检测会更加简洁高效，从而更快的解决n皇后问题</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> MAX=(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> <span class="comment">//row表示列，left表示左对角线，right表示右对角线，为1是不能放的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row!=MAX) <span class="comment">//如果不是所有列都有皇后 </span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=MAX&amp;~(row|ld|rd); <span class="comment">//pos表示可以放的位置</span></span><br><span class="line">        <span class="keyword">while</span>(pos!=<span class="number">0</span>) <span class="comment">//while循环枚举所有为1的位置，然后去放置皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=pos&amp;(-pos);<span class="comment">//lowbit操作，提取出最后一个1所在的位置</span></span><br><span class="line">            pos=pos^p; <span class="comment">//将p位置在pos中置为0</span></span><br><span class="line">            <span class="comment">//row|p把p二进制为1的位置放上皇后</span></span><br><span class="line">            <span class="comment">//(left|p)&lt;&lt;1更新left的下一行不能放的位置</span></span><br><span class="line">            <span class="comment">//(right|p)&gt;&gt;1更新right的下一行不能放的位置</span></span><br><span class="line">            f(row|p,(ld|p)&lt;&lt;<span class="number">1</span>,(rd|p)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//如果所有列都有皇后，则找到了一种可行的方法 </span></span><br><span class="line">		ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//因为没有放皇后，所以所有都是0 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
